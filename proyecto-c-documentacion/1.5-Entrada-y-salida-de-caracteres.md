# 1.5. Entrada y Salida de Caracteres

La entrada y salida (E/S) de caracteres es una de las operaciones más fundamentales en C. Se realiza carácter por carácter y es la base para procesar texto, leer archivos y manejar la interacción con el usuario en la terminal.

Las dos funciones principales para la E/S de caracteres son:

- `getchar()`: Lee un solo carácter desde la entrada estándar (generalmente el teclado).
- `putchar()`: Escribe un solo carácter en la salida estándar (generalmente la pantalla).

Ambas funciones están definidas en la biblioteca estándar de E/S, por lo que debes incluir el encabezado `<stdio.h>`.

## `getchar()`

- Lee el siguiente carácter disponible en el flujo de entrada.
- Devuelve el carácter leído como un valor de tipo `int`.
- Si se llega al final del flujo de entrada (conocido como "End-Of-File" o EOF), o si ocurre un error, `getchar()` devuelve el valor especial `EOF`.

### ¿Por qué devuelve `int` y no `char`?

Un `char` puede almacenar todos los caracteres posibles (ej. 256 valores en ASCII extendido). Sin embargo, `getchar()` necesita una forma de devolver un valor que esté _fuera_ de ese rango para indicar el fin de archivo (`EOF`). Por lo tanto, utiliza un `int`, que tiene un rango mucho más amplio, para poder devolver tanto cualquier carácter válido como el valor especial `EOF`.

Es crucial declarar la variable que almacena el resultado de `getchar()` como `int`.

```c
int c;
c = getchar(); // Correcto
```

```c
char c;
c = getchar(); // Incorrecto: podría fallar al detectar EOF
```

## `putchar()`

- Toma un argumento de tipo `int` (que contiene un carácter) y lo escribe en el flujo de salida.
- Devuelve el carácter escrito si tiene éxito, o `EOF` si ocurre un error.

```c
int c = 'A';
putchar(c); // Escribe 'A' en la pantalla
```

## Ejemplo: Copiar la entrada a la salida

Este es un programa clásico que demuestra el uso básico de `getchar()` y `putchar()`. Lee caracteres de la entrada uno por uno y los imprime en la salida hasta que se encuentra el final del archivo.

```c
#include <stdio.h>

int main() {
    int c;

    c = getchar();
    while (c != EOF) {
        putchar(c);
        c = getchar();
    }

    return 0;
}
```

### Versión más concisa

En C, es muy común anidar la asignación dentro de la condición del `while`, lo que produce un código más compacto:

```c
#include <stdio.h>

int main() {
    int c;

    // La expresión (c = getchar()) se evalúa al valor asignado a c
    while ((c = getchar()) != EOF) {
        putchar(c);
    }

    return 0;
}
```

**Importancia de los paréntesis:** Los paréntesis alrededor de `c = getchar()` son necesarios porque el operador `!=` tiene mayor precedencia que `=`. Sin ellos, la expresión se evaluaría como `c = (getchar() != EOF)`, lo que asignaría a `c` el valor `1` (verdadero) o `0` (falso), en lugar del carácter leído.

## ¿Cómo se genera `EOF`?

`EOF` (End-Of-File) es una constante simbólica definida en `<stdio.h>` que representa el fin de un flujo de datos. No es un carácter real.

- **En Windows:** Puedes simular `EOF` desde el teclado presionando `Ctrl+Z` seguido de `Enter`.
- **En Linux/macOS:** Se genera con `Ctrl+D`.
- Cuando se lee un archivo, `EOF` se alcanza automáticamente al llegar al final del mismo.

## Comparación con JavaScript (en un entorno como Node.js)

En Node.js, la E/S se maneja de forma asíncrona y a través de flujos (streams).

- **Leer de la entrada estándar:**
  ```javascript
  process.stdin.on("data", (chunk) => {
    // Procesa el 'chunk' de datos
    process.stdout.write(chunk); // Escribe en la salida
  });
  ```
- **Diferencias clave:**
  - **Modelo de E/S:** C utiliza un modelo de E/S síncrono y bloqueante por defecto (`getchar()` detiene la ejecución hasta que recibe un carácter). Node.js usa un modelo asíncrono y no bloqueante basado en eventos.
  - **Abstracción:** `getchar()` y `putchar()` operan a un nivel muy bajo (carácter por carácter). Los flujos de Node.js suelen trabajar con "chunks" (trozos) de datos, que son más eficientes para grandes volúmenes de información.
  - **Manejo de fin de flujo:** En C, se comprueba el valor `EOF`. En Node.js, se escuchan eventos como `'end'`.

El modelo de C es más simple y directo, ideal para aprender los fundamentos, mientras que el de JavaScript está optimizado para aplicaciones de red de alto rendimiento.

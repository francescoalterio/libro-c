# 1.5. Entrada y Salida de Caracteres

La entrada y salida (E/S) de caracteres es la base del procesamiento de texto en C. Se realiza carácter por carácter y es fundamental para leer desde el teclado, escribir en la pantalla o procesar archivos.

Las dos funciones más importantes para esta tarea son `getchar()` y `putchar()`, ambas definidas en `<stdio.h>`.

## `getchar()`: Lectura de un Carácter

- **Propósito:** Lee el siguiente carácter disponible desde la **entrada estándar** (normalmente, el teclado).
- **Valor de Retorno:** Devuelve el carácter leído como un valor de tipo `int`. Si se alcanza el final del flujo de datos (End-Of-File o `EOF`) o si ocurre un error, devuelve la constante `EOF`.

### La importancia de `int` para `getchar()`

Es crucial que la variable que almacena el resultado de `getchar()` sea de tipo `int`, no `char`.

- Un `char` puede almacenar todos los caracteres posibles del conjunto de caracteres (ej. 256 valores).
- `EOF` es un valor especial, fuera de ese rango, que indica que no hay más datos.
- Un `int` es lo suficientemente grande para contener todos los valores de `char` **y además** el valor de `EOF`.

```c
int c;
c = getchar(); // Correcto. 'c' puede almacenar cualquier carácter o EOF.
```

```c
char c;
c = getchar(); // ¡Incorrecto! Si getchar() devuelve EOF, la comparación c == EOF podría fallar.
```

## `putchar()`: Escritura de un Carácter

- **Propósito:** Escribe un solo carácter en la **salida estándar** (normalmente, la pantalla).
- **Argumento:** Toma un `int` que contiene el carácter a escribir.

```c
int c = 'A';
putchar(c); // Escribe 'A' en la pantalla.
putchar('\n'); // Escribe un carácter de nueva línea.
```

## Modelo de E/S: Copia de Entrada a Salida

El siguiente programa es un pilar en la programación en C. Lee caracteres de la entrada y los escribe en la salida, uno por uno, hasta que se encuentra el final del flujo.

```c
#include <stdio.h>

/* Copia la entrada a la salida; 1ra versión */
int main() {
    int c;

    c = getchar();
    while (c != EOF) {
        putchar(c);
        c = getchar();
    }
    return 0;
}
```

### Versión idiomática y concisa

En C, es muy común anidar la asignación dentro de la condición del `while`. Esto produce un código más compacto y es un modismo que todo programador de C reconoce.

```c
#include <stdio.h>

/* Copia la entrada a la salida; 2da versión (idiomática) */
int main() {
    int c;

    // La expresión (c = getchar()) se evalúa al valor que se asigna a c.
    while ((c = getchar()) != EOF) {
        putchar(c);
    }
    return 0;
}
```

**¡Cuidado con la precedencia!** Los paréntesis alrededor de `c = getchar()` son **obligatorios**. El operador de desigualdad `!=` tiene mayor precedencia que el de asignación `=`.

- `while (c = getchar() != EOF)` se evaluaría como `c = (getchar() != EOF)`.
- Esto asignaría a `c` el valor `0` o `1` (el resultado de la comparación), no el carácter leído.

## ¿Qué es `EOF`?

`EOF` (End-Of-File) es una constante entera definida en `<stdio.h>` que representa el fin de un flujo de datos. **No es un carácter real** y su valor numérico es negativo (comúnmente -1).

- **Desde el teclado (simulación):**
  - **Windows:** `Ctrl+Z` seguido de `Enter`.
  - **Linux/macOS:** `Ctrl+D`.
- **Desde un archivo:** Cuando un programa lee un archivo, `getchar()` devolverá `EOF` automáticamente al llegar al final del mismo.

## Comparación con JavaScript (Node.js)

En Node.js, la E/S se maneja de forma asíncrona y a través de flujos (streams), un modelo muy diferente.

- **Leer de la entrada estándar:**

  ```javascript
  // El evento 'data' se dispara cada vez que llega un trozo (chunk) de datos.
  process.stdin.on("data", (chunk) => {
    // El chunk es un Buffer, no un solo carácter.
    process.stdout.write(`Datos recibidos: ${chunk}`);
  });

  // El evento 'end' se dispara cuando el flujo de entrada termina (equivale a EOF).
  process.stdin.on("end", () => {
    console.log("Fin del flujo de entrada.");
  });
  ```

- **Modelo:** La E/S en C es **bloqueante** y **síncrona** por defecto (`getchar()` espera hasta que haya un carácter). En Node.js es **no bloqueante** y **asíncrona**, basada en eventos. process.stdout.write(chunk); // Escribe en la salida
  });
  ```

  ```
- **Diferencias clave:**
  - **Modelo de E/S:** C utiliza un modelo de E/S síncrono y bloqueante por defecto (`getchar()` detiene la ejecución hasta que recibe un carácter). Node.js usa un modelo asíncrono y no bloqueante basado en eventos.
  - **Abstracción:** `getchar()` y `putchar()` operan a un nivel muy bajo (carácter por carácter). Los flujos de Node.js suelen trabajar con "chunks" (trozos) de datos, que son más eficientes para grandes volúmenes de información.
  - **Manejo de fin de flujo:** En C, se comprueba el valor `EOF`. En Node.js, se escuchan eventos como `'end'`.

El modelo de C es más simple y directo, ideal para aprender los fundamentos, mientras que el de JavaScript está optimizado para aplicaciones de red de alto rendimiento.

# 1.5.1. Copia de Archivos

El programa que copia su entrada a la salida, presentado en la sección anterior, es mucho más que un simple ejercicio. Es el prototipo de una gran cantidad de programas útiles conocidos como **filtros**: programas que leen datos de una fuente, los transforman de alguna manera y los escriben en un destino.

## El Programa Canónico de Copia

Recordemos la versión idiomática del programa:

```c
#include <stdio.h>

/* Copia la entrada a la salida, carácter por carácter */
int main() {
    int c;

    while ((c = getchar()) != EOF) {
        putchar(c);
    }
    return 0;
}
```

A primera vista, parece que solo copia lo que escribes en el teclado a la pantalla. Sin embargo, su verdadero poder se revela cuando se combina con las capacidades de la línea de comandos de cualquier sistema operativo moderno.

## El Poder de la Redirección de E/S

La **redirección de E/S** permite cambiar de dónde proviene la entrada estándar y a dónde va la salida estándar.

- El operador `<` redirige la entrada: `programa < archivo_entrada.txt` hace que `getchar()` lea desde `archivo_entrada.txt` en lugar del teclado.
- El operador `>` redirige la salida: `programa > archivo_salida.txt` hace que `putchar()` escriba en `archivo_salida.txt` en lugar de la pantalla.

### Copiando un Archivo

Usando la redirección, nuestro simple programa se convierte en una utilidad para copiar archivos. Si compilamos nuestro programa en un ejecutable llamado `copiar`:

**Comando para copiar `origen.txt` a `destino.txt`:**

```bash
./copiar < origen.txt > destino.txt
```

**Desglose del comando:**

1.  `./copiar`: Ejecuta nuestro programa.
2.  `< origen.txt`: La entrada estándar (`stdin`) se conecta al archivo `origen.txt`. Ahora, `getchar()` lee los caracteres de este archivo.
3.  `> destino.txt`: La salida estándar (`stdout`) se conecta al archivo `destino.txt`. Ahora, `putchar()` escribe los caracteres en este archivo.

El resultado es una copia exacta de `origen.txt` en `destino.txt`. Si `destino.txt` no existe, se crea. Si existe, se sobrescribe.

### El comando `cat`

Este comportamiento es idéntico al del comando `cat` en sistemas Unix/Linux. `cat` (de "concatenate") puede usarse para mostrar el contenido de un archivo en la pantalla o para concatenar y copiar archivos.

```bash
# Muestra el contenido de un archivo en la terminal (la salida es la pantalla por defecto)
./copiar < mi_archivo.txt

# Es equivalente a:
cat mi_archivo.txt
```

## Comparación con JavaScript (Node.js)

En Node.js, el concepto de flujos (streams) y "piping" (tuberías) hace esta tarea muy elegante. El siguiente script es el equivalente funcional de nuestro programa en C.

```javascript
// copiar.js

// process.stdin es un stream de lectura para la entrada estándar.
// process.stdout es un stream de escritura para la salida estándar.

// .pipe() conecta la salida de un stream con la entrada de otro.
// Lee todos los datos de stdin y los escribe directamente en stdout.
process.stdin.pipe(process.stdout);

console.error("Copiando datos... (Este mensaje va a stderr)");
```

Para usarlo de la misma forma que el programa en C:

```bash
# Ejecuta el script de Node.js para copiar un archivo
node copiar.js < origen.txt > destino.txt
```

El modelo de Node.js es de más alto nivel, manejando los datos en "chunks" (trozos) en lugar de carácter por carácter, lo cual es generalmente más eficiente para archivos grandes. Sin embargo, el principio de leer de una fuente y escribir a un destino es el mismo.

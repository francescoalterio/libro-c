# 1.5.2. Conteo de Caracteres

Basándonos en el bucle de E/S de `getchar()`, podemos construir fácilmente programas que realicen análisis simples sobre el texto de entrada, como contar el número total de caracteres.

## Programa para Contar Caracteres

El objetivo es leer caracteres de la entrada uno por uno hasta llegar al final del archivo (`EOF`), y por cada carácter leído, incrementar un contador.

```c
#include <stdio.h>

/* Contar los caracteres de la entrada; 1a. versión */
int main() {
    long nc; // Usamos 'long' para poder contar números grandes

    nc = 0;
    while (getchar() != EOF) {
        ++nc; // Incrementa el contador por cada carácter
    }

    printf("%ld\n", nc); // Imprime el total. %ld es para long int.

    return 0;
}
```

### Desglose del Código

1.  **`long nc;`**: Declaramos una variable `nc` (number of characters) de tipo `long`. Usamos `long` en lugar de `int` porque un `int` podría no ser suficiente para almacenar el número de caracteres de un archivo muy grande. El tamaño de `int` depende del sistema, pero `long` garantiza un rango mayor.
2.  **`nc = 0;`**: Inicializamos el contador a cero.
3.  **`while (getchar() != EOF)`**: Este es el corazón del programa.
    - `getchar()` lee un carácter.
    - El carácter leído se compara con `EOF`.
    - Mientras no sea `EOF`, el bucle continúa. El carácter en sí no se almacena en ninguna variable, simplemente se descarta después de la comprobación.
4.  **`++nc;`**: Dentro del bucle, por cada carácter que se lee (y que no es `EOF`), incrementamos nuestro contador `nc`. `++nc` es el operador de pre-incremento, que es funcionalmente igual a `nc = nc + 1` o `nc++` en este contexto.
5.  **`printf("%ld\n", nc);`**: Una vez que el bucle termina (cuando `getchar()` devuelve `EOF`), esta línea imprime el valor final del contador.
    - `%ld` es el especificador de formato para imprimir una variable de tipo `long int`. Si hubiéramos usado `int`, el especificador sería `%d`.

## Segunda Versión con un Ciclo `for`

La misma lógica se puede expresar de forma más compacta utilizando un ciclo `for`. Las tres partes del `for` (inicialización, condición e incremento) están vacías, ya que toda la lógica está contenida en la inicialización y en el cuerpo del bucle.

```c
#include <stdio.h>

/* Contar los caracteres de la entrada; 2a. versión */
int main() {
    double nc; // Usar double también funciona, aunque es menos convencional

    for (nc = 0; getchar() != EOF; ++nc) {
        ; // El cuerpo del bucle está vacío
    }

    printf("%.0f\n", nc); // %.0f imprime un double sin decimales

    return 0;
}
```

### Análisis de la versión con `for`

- **`nc = 0`**: La inicialización del `for` establece el contador a cero.
- **`getchar() != EOF`**: La condición del `for` sigue siendo la misma. Se ejecuta antes de cada "iteración".
- **`++nc`**: La parte de incremento del `for` se ejecuta después de cada iteración (es decir, después de que se haya leído un carácter con éxito).
- **`;`**: El punto y coma solitario es el "cuerpo" del bucle. Es una proposición nula. Significa que no hay que hacer nada dentro del bucle; toda la acción ocurre en las cabeceras del `for`.

Ambas versiones son funcionalmente idénticas. La elección entre `while` y `for` es a menudo una cuestión de estilo y claridad. La primera versión con `while` suele ser más fácil de leer para los principiantes.

## ¿Cómo probarlo?

1.  Compila el programa (ej. `gcc contador.c -o contador`).
2.  Ejecútalo: `./contador`.
3.  Escribe texto en la terminal, por ejemplo: `hola`.
4.  Presiona `Enter`.
5.  Para finalizar la entrada, presiona `Ctrl+D` (en Linux/macOS) o `Ctrl+Z` y luego `Enter` (en Windows).
6.  El programa imprimirá el número de caracteres. Para "hola" seguido de `Enter`, serían 5 caracteres (`h`, `o`, `l`, `a`, y el carácter de nueva línea `\n`).

También puedes usarlo con redirección para contar los caracteres de un archivo:
`./contador < mi_archivo.txt`

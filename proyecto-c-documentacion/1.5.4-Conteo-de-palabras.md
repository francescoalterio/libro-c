# 1.5.4. Conteo de Palabras

Contar palabras es un problema más complejo que contar líneas o caracteres, porque una "palabra" no es un solo carácter. Necesitamos definir qué constituye una palabra. Una definición común es:

> Una palabra es una secuencia de caracteres que no contiene espacios en blanco (espacio, tabulador, nueva línea).

Para contar palabras, nuestro programa necesita "recordar" si el carácter anterior que vio era parte de una palabra o era un espacio en blanco. Esta idea de **mantener un estado** es clave en muchos algoritmos.

Usaremos una variable de estado, `state`, para saber si actualmente estamos **dentro** de una palabra (`IN`) o **fuera** de una palabra (`OUT`).

## Lógica del Programa

1.  Inicializar el contador de palabras `nw` a 0.
2.  Inicializar el estado `state` a `OUT` (porque al principio no estamos dentro de una palabra).
3.  Leer cada carácter uno por uno hasta `EOF`.
4.  Para cada carácter:
    - Si el carácter es un espacio, un tabulador (`\t`) o una nueva línea (`\n`), estamos "fuera" de una palabra. Cambiamos el estado a `OUT`.
    - Si el carácter **no** es un espacio en blanco:
      - Y si nuestro estado anterior era `OUT`, significa que acabamos de encontrar el **comienzo** de una nueva palabra. Por lo tanto, incrementamos el contador de palabras `nw` y cambiamos el estado a `IN` para recordar que ahora estamos dentro de una palabra.
      - Si nuestro estado anterior ya era `IN`, simplemente continuamos, ya que seguimos dentro de la misma palabra y no debemos contarla de nuevo.

## Programa `wc` Simplificado

El siguiente programa implementa esta lógica. Además, cuenta líneas y caracteres para ser una versión simplificada de la famosa utilidad `wc` de Unix.

```c
#include <stdio.h>

// Usamos constantes simbólicas para el estado, mejora la legibilidad.
#define IN  1   // Estamos dentro de una palabra
#define OUT 0   // Estamos fuera de una palabra

/* Contar líneas, palabras y caracteres de la entrada */
int main() {
    int c, nl, nw, nc, state;

    state = OUT;
    nl = nw = nc = 0; // Inicializa todos los contadores a 0

    while ((c = getchar()) != EOF) {
        ++nc; // Siempre cuenta el carácter

        if (c == '\n') {
            ++nl; // Cuenta la línea
        }

        // Lógica para cambiar de estado
        if (c == ' ' || c == '\n' || c == '\t') {
            state = OUT; // Si es un espacio en blanco, estamos fuera
        } else if (state == OUT) {
            // Si no es un espacio en blanco y estábamos fuera...
            state = IN;  // ...hemos entrado en una palabra...
            ++nw;        // ...así que la contamos.
        }
    }

    printf("Líneas: %d\nPalabras: %d\nCaracteres: %d\n", nl, nw, nc);

    return 0;
}
```

### Desglose del Código

1.  **`#define IN 1` y `#define OUT 0`**: Usar constantes simbólicas en lugar de números "mágicos" como 1 y 0 hace el código mucho más fácil de entender. `state = IN;` es más claro que `state = 1;`.
2.  **`int c, nl, nw, nc, state;`**: Declaramos variables para el carácter (`c`), contadores de líneas (`nl`), palabras (`nw`), caracteres (`nc`), y nuestra variable de estado (`state`).
3.  **`state = OUT;`**: Empezamos "fuera" de una palabra.
4.  **`nl = nw = nc = 0;`**: C permite asignaciones múltiples. Esta línea es una forma compacta de inicializar todos los contadores a cero.
5.  **`if (c == ' ' || c == '\n' || c == '\t')`**: Comprueba si el carácter actual es un espacio, una nueva línea o un tabulador. El operador `||` significa "O lógico".
6.  **`else if (state == OUT)`**: Esta es la parte crucial. Este bloque solo se ejecuta si el carácter **no** es un espacio en blanco. Dentro de él, comprobamos si veníamos de estar "fuera" de una palabra.
    - Si ambas condiciones son ciertas (el carácter no es un espacio Y estábamos fuera), significa que hemos encontrado el primer carácter de una nueva palabra.
    - Cambiamos `state` a `IN` y, lo más importante, incrementamos `nw`.

## Ejemplo de Ejecución

Imagina que la entrada es: `hola  mundo` (con dos espacios)

| Carácter `c` | `c` es espacio? | `state` antes | Acción                | `state` después | `nw` |
| :----------- | :-------------- | :------------ | :-------------------- | :-------------- | :--- |
| `h`          | No              | `OUT`         | `state`= `IN`, `nw`++ | `IN`            | 1    |
| `o`          | No              | `IN`          | (ninguna)             | `IN`            | 1    |
| `l`          | No              | `IN`          | (ninguna)             | `IN`            | 1    |
| `a`          | No              | `IN`          | (ninguna)             | `IN`            | 1    |
| ` `          | Sí              | `IN`          | `state` = `OUT`       | `OUT`           | 1    |
| ` `          | Sí              | `OUT`         | `state` = `OUT`       | `OUT`           | 1    |
| `m`          | No              | `OUT`         | `state`= `IN`, `nw`++ | `IN`            | 2    |
| `u`          | No              | `IN`          | (ninguna)             | `IN`            | 2    |
| ...          | ...             | ...           | ...                   | ...             | ...  |

El resultado final será `Palabras: 2`. El programa maneja correctamente múltiples espacios entre palabras.

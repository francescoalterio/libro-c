# 1.9. Arreglos de Caracteres (Cadenas o Strings)

En C, no existe un tipo de dato "string" como en lenguajes de alto nivel. En su lugar, una cadena de texto se representa como un **arreglo de caracteres**. La convención fundamental es que una cadena debe terminar con un carácter especial: el **carácter nulo** (`'\0'`), que marca el final de la cadena.

Esta simple convención es la base de toda la manipulación de texto en C y es crucial entenderla para evitar errores.

## El Rol Crítico del Carácter Nulo (`\0`)

El carácter nulo es un byte con todos sus bits en cero. No es el carácter `'0'`, que tiene un valor ASCII diferente. Su propósito es indicar a las funciones de la biblioteca estándar (como `printf`, `strlen`, `strcpy`, etc.) dónde termina la cadena. Sin él, estas funciones seguirían leyendo memoria consecutiva sin parar, llevando a comportamientos indefinidos y fallos.

### Declaración e Inicialización

```c
// 1. Usando un literal de cadena (la forma más común)
// El compilador añade automáticamente el '\0' al final.
char saludo[] = "Hola"; // Reserva 5 bytes: 'H','o','l','a','\0'

// 2. Inicialización explícita como arreglo
// Debes añadir manualmente el '\0'.
char despedida[5] = {'A', 'd', 'i', 'o', 's'}; // ¡ERROR! Falta espacio para '\0'
char despedida_ok[6] = {'A', 'd', 'i', 'o', 's', '\0'}; // Correcto
```

## Ejemplo Práctico: Leer y Copiar la Línea más Larga

Este programa lee líneas de texto de la entrada y guarda la línea más larga que encuentra, demostrando el manejo básico de arreglos de caracteres.

```c
#include <stdio.h>
#define MAXLINE 1000 /* tamaño máximo de la línea de entrada */

int getline_custom(char line[], int maxline);
void copy(char to[], char from[]);

/* Imprimir la línea de entrada más larga */
int main() {
    int len;               /* longitud de la línea actual */
    int max;               /* máxima longitud vista hasta el momento */
    char line[MAXLINE];    /* línea de entrada actual */
    char longest[MAXLINE]; /* la línea más larga se guarda aquí */

    max = 0;
    while ((len = getline_custom(line, MAXLINE)) > 0) {
        if (len > max) {
            max = len;
            copy(longest, line);
        }
    }

    if (max > 0) { /* hubo una línea */
        printf("\nLa línea más larga es:\n%s", longest);
    }

    return 0;
}

/* getline_custom: lee una línea en s, regresa su longitud */
int getline_custom(char s[], int lim) {
    int c, i;

    for (i = 0; i < lim - 1 && (c = getchar()) != EOF && c != '\n'; ++i) {
        s[i] = c;
    }
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0'; // ¡Añade el carácter nulo al final!
    return i;
}

/* copy: copia 'from' en 'to'; supone que to es suficientemente grande */
void copy(char to[], char from[]) {
    int i = 0;
    while ((to[i] = from[i]) != '\0') {
        ++i;
    }
}
```

### Desglose del Código

- **`getline_custom`**: Lee caracteres hasta encontrar un salto de línea (`\n`) o `EOF`, o hasta llenar el búfer. Crucialmente, siempre termina la cadena con `\0`.
- **`copy`**: Copia caracteres de un arreglo a otro hasta que encuentra el `\0` en el origen. La asignación `(to[i] = from[i])` devuelve el valor asignado, que se compara con `\0` para detener el bucle.

## Peligro: Desbordamiento de Búfer (Buffer Overflow)

El mayor riesgo al trabajar con cadenas en C es escribir más allá de los límites del arreglo. Si un arreglo fue declarado con tamaño 20 e intentas copiar una cadena de 30 caracteres en él, sobrescribirás memoria adyacente, lo que puede causar fallos impredecibles o crear graves vulnerabilidades de seguridad.

**Siempre debes asegurarte de que el arreglo de destino sea lo suficientemente grande para contener la cadena de origen, incluyendo el carácter nulo.**

## Comparación Detallada: C vs. JavaScript

| Característica        | Cadenas en C                                                   | Cadenas en JavaScript                                                                 |
| :-------------------- | :------------------------------------------------------------- | :------------------------------------------------------------------------------------ |
| **Tipo**              | Arreglo de `char` terminado en `\0`.                           | Tipo de dato primitivo (inmutable) u objeto `String`.                                 |
| **Mutabilidad**       | **Mutables**. Puedes cambiar caracteres individuales.          | **Inmutables**. No se pueden cambiar. Cualquier "modificación" crea una nueva cadena. |
| **Longitud**          | Se calcula con `strlen()` recorriendo hasta `\0`.              | Propiedad `.length` de acceso instantáneo.                                            |
| **Manejo de Memoria** | Manual. El programador debe asignar y gestionar el espacio.    | Automático (recolector de basura).                                                    |
| **Seguridad**         | Propenso a desbordamientos de búfer.                           | Seguro. No hay riesgo de desbordamiento.                                              |
| **Operaciones**       | Mediante funciones de `<string.h>` (`strcpy`, `strcat`, etc.). | Mediante métodos del objeto String (`.slice`, `.concat`, etc.).                       |

## Resumen

Manejar cadenas en C es manejar arreglos de caracteres con la regla del `\0`. Este enfoque de bajo nivel ofrece un gran rendimiento pero exige una programación disciplinada para gestionar la memoria y evitar desbordamientos. Las funciones de la biblioteca `<string.h>` son tus herramientas esenciales, pero siempre debes usarlas conociendo el tamaño de tus arreglos.

# 2.9. Operadores para Manejo de Bits

C proporciona un potente conjunto de operadores que permiten la manipulación directa de los bits que componen un valor. Estos son cruciales en áreas como la programación de sistemas, controladores de dispositivos, criptografía y en algoritmos que requieren una alta optimización o un empaquetado de datos eficiente.

Estos operadores solo se aplican a tipos de datos **enteros** (`char`, `short`, `int`, `long`, etc.), tanto con signo (`signed`) como sin signo (`unsigned`).

## Operadores Lógicos Bit a Bit

Estos operadores comparan los bits correspondientes de dos operandos.

| Operador | Nombre             | Descripción                                                   |
| :------- | :----------------- | :------------------------------------------------------------ | ------------------------------------------------------------------- |
| `&`      | AND                | El bit resultante es 1 solo si ambos bits de entrada son 1.   |
| `        | `                  | OR Inclusivo                                                  | El bit resultante es 1 si al menos uno de los bits de entrada es 1. |
| `^`      | OR Exclusivo (XOR) | El bit resultante es 1 si los bits de entrada son diferentes. |

**Ejemplo:**

```c
unsigned char a = 9;  // 00001001
unsigned char b = 12; // 00001100
------------------------------------
a & b             // 00001000  (Resultado: 8)
a | b             // 00001101  (Resultado: 13)
a ^ b             // 00000101  (Resultado: 5)
```

**¡No confundir `&` con `&&`!**

- `&` es el AND a nivel de bits.
- `&&` es el AND lógico. `if (x != 0 && y != 0)` es muy diferente de `if (x & y)`.

## Operadores de Desplazamiento (Shift)

Estos operadores mueven los bits de un operando hacia la izquierda o hacia la derecha.

| Operador | Nombre                        | Descripción                                                                                                                                                                   |
| :------- | :---------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `<<`     | Desplazamiento a la Izquierda | `x << n` desplaza los bits de `x` a la izquierda `n` posiciones. Los bits que salen por la izquierda se descartan. Los nuevos bits que entran por la derecha son siempre `0`. |
| `>>`     | Desplazamiento a la Derecha   | `x >> n` desplaza los bits de `x` a la derecha `n` posiciones. Los bits que salen por la derecha se descartan.                                                                |

**Comportamiento del Desplazamiento a la Derecha (`>>`):**

- **Para enteros `unsigned`:** Los nuevos bits que entran por la izquierda son siempre `0` (desplazamiento lógico).
- **Para enteros `signed`:** El comportamiento depende de la implementación del compilador. Puede ser un desplazamiento lógico (se insertan ceros) o un **desplazamiento aritmético** (se insertan copias del bit de signo). Generalmente, es aritmético para preservar el signo del número.

**Ejemplo:**

```c
unsigned char x = 18; // 00010010

x << 2; // 01001000 (Resultado: 72). Equivale a multiplicar por 4.
x >> 2; // 00000100 (Resultado: 4). Equivale a dividir por 4.
```

**Optimización:** Desplazar a la izquierda `n` bits es equivalente a multiplicar por 2<sup>n</sup>. Desplazar a la derecha `n` bits es equivalente a dividir por 2<sup>n</sup>. Las operaciones de desplazamiento suelen ser mucho más rápidas que las multiplicaciones/divisiones.

## Operador de Complemento a Uno (`~`)

Este es un operador unario que invierte todos los bits de su operando: cada `1` se convierte en `0` y cada `0` en `1`.

```c
unsigned char a = 9; // 00001001
~a;                  // 11110110 (Resultado: 246 si es unsigned char)
```

El resultado numérico exacto de `~x` depende del tamaño del tipo de dato y de si es con o sin signo.

## Usos Comunes

1.  **Máscaras de Bits (Masking):** Usar `&` para verificar el estado de un bit específico.

    ```c
    #define FLAG_A 0x01 // ...0001
    #define FLAG_B 0x02 // ...0010

    unsigned char status = 0x03; // ...0011 (Ambos flags activos)

    // ¿Está FLAG_A activo?
    if (status & FLAG_A) { /* sí */ }
    ```

2.  **Encender un Bit (Setting a Bit):** Usar `|` para forzar un bit a 1.

    ```c
    // Activar FLAG_B en status
    status = status | FLAG_B;
    ```

3.  **Apagar un Bit (Clearing a Bit):** Usar `&` con una máscara invertida (`~`).

    ```c
    // Apagar FLAG_A en status
    status = status & ~FLAG_A; // ~FLAG_A es ...1110
    ```

4.  **Invertir un Bit (Toggling a Bit):** Usar `^` (XOR).
    ```c
    // Si FLAG_A está encendido, lo apaga. Si está apagado, lo enciende.
    status = status ^ FLAG_A;
    ```

## Comparación con JavaScript

JavaScript también tiene todos estos operadores de bits (`&`, `|`, `^`, `~`, `<<`, `>>`, y también `>>>` para el desplazamiento a la derecha sin signo). Sin embargo, en JS, todos los números son tratados como `double` de 64 bits. Cuando se aplica un operador de bits, JavaScript convierte el número a un entero de 32 bits con signo, realiza la operación y luego lo convierte de nuevo a `double`. Esto puede ser menos eficiente y el control sobre el tamaño del dato es mucho menor que en C.

## Resumen

- Los operadores de bits son herramientas de bajo nivel para manipular datos enteros bit por bit.
- Son esenciales para la programación de sistemas y la optimización.
- Permiten empaquetar eficientemente múltiples valores booleanos (flags) en un solo entero.
- Es crucial no confundir los operadores de bits (`&`, `|`) con sus contrapartes lógicas (`&&`, `||`).

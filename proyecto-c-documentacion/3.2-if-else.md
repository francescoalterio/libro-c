# 3.2. if-else

La proposición `if-else` es la herramienta fundamental en C para la toma de decisiones. Permite que un programa ejecute diferentes caminos de código basándose en si una condición es verdadera o falsa.

## Sintaxis

La estructura básica es la siguiente:

```c
if (expresion)
    proposicion_1
else
    proposicion_2
```

**Cómo funciona:**

1.  Se evalúa la `expresion` entre paréntesis.
2.  Si el resultado es **verdadero** (es decir, cualquier valor distinto de cero), se ejecuta la `proposicion_1`.
3.  Si el resultado es **falso** (cero), se ejecuta la `proposicion_2`.

Como un bloque `{ ... }` puede usarse en cualquier lugar donde se permite una sola proposición, la forma más común y recomendada es:

```c
if (expresion) {
    // Bloque de código si la condición es verdadera
} else {
    // Bloque de código si la condición es falsa
}
```

La parte `else` es opcional. Si se omite, no se realiza ninguna acción cuando la condición es falsa.

```c
if (expresion) {
    // Bloque de código si la condición es verdadera
}
// La ejecución continúa aquí si la condición es falsa.
```

## La Condición en C

A diferencia de otros lenguajes que tienen un tipo booleano `true`/`false` explícito, en C la condición de un `if` se basa en valores enteros:

- Un valor de **cero (0)** se interpreta como **falso**.
- **Cualquier valor distinto de cero** se interpreta como **verdadero**.

```c
if (1) { // Siempre se ejecuta
    printf("1 es verdadero\n");
}

if (0) { // Nunca se ejecuta
    printf("0 es falso\n");
}

int lineas = 10;
if (lineas) { // Verdadero, porque lineas no es 0
    printf("Hay líneas que procesar.\n");
}
```

## El Problema del "Dangling Else" (Else Colgante)

Cuando se anidan `if` sin usar llaves, puede surgir una ambigüedad conocida como el "dangling else". La regla en C es simple: **un `else` siempre se asocia con el `if` más cercano que no tenga ya un `else`**.

**Ejemplo ambiguo:**

```c
int a = 1, b = 0;

if (a == 1)
    if (b == 1)
        printf("a es 1 y b es 1\n");
else // ¿A qué if pertenece este else?
    printf("Condición externa falsa\n");
```

Según la regla, el `else` se asocia con `if (b == 1)`. El código es equivalente a:

```c
if (a == 1) {
    if (b == 1) {
        printf("a es 1 y b es 1\n");
    } else { // Asociado al if interno
        printf("Condición externa falsa\n"); // ¡Mensaje engañoso!
    }
}
```

Como `b` no es 1, se imprimirá el mensaje del `else`, lo cual puede no ser la intención original.

**Solución:** ¡Usa siempre llaves `{}` para eliminar la ambigüedad!

```c
if (a == 1) {
    if (b == 1) {
        printf("a es 1 y b es 1\n");
    }
} else {
    printf("Condición externa falsa\n");
}
```

Con las llaves, el `else` se asocia claramente con el `if (a == 1)`, y el código se comporta como se espera (en este caso, no imprimiría nada).

## Comparación con JavaScript

La sintaxis y el comportamiento de `if-else` en JavaScript son **prácticamente idénticos** a los de C. La principal diferencia radica en la coerción de tipos de JavaScript. Mientras que en C la condición es numérica (0 o no 0), en JavaScript muchos valores pueden ser "truthy" o "falsy" (ej. `null`, `undefined`, `""` son falsy). Sin embargo, la estructura `if (condicion) { ... } else { ... }` es la misma. El problema del "dangling else" también existe en JavaScript si se omite el uso de llaves.

## Resumen

- `if-else` es la estructura de control de flujo principal para la toma de decisiones.
- La condición se considera falsa si es `0` y verdadera para cualquier otro valor.
- La parte `else` es opcional.
- **Usa siempre llaves `{}`** para agrupar las proposiciones, incluso si solo hay una. Esto previene errores como el "dangling else" y mejora drásticamente la legibilidad y el mantenimiento del código.

# 3.8. `goto` y Etiquetas

La proposición `goto` y las etiquetas (`labels`) proporcionan un mecanismo para transferir el control de forma incondicional a cualquier otra parte de la misma función. Aunque es una característica poderosa, su uso es muy controvertido y, en general, se desaconseja en la programación moderna.

## Sintaxis

La estructura consta de dos partes:

1.  **La proposición `goto`**:

    ```c
    goto nombre_etiqueta;
    ```

2.  **La etiqueta (`label`)**: Es un identificador seguido de dos puntos (`:`).
    ```c
    nombre_etiqueta: proposicion;
    ```

Una etiqueta puede ser colocada antes de cualquier proposición dentro de la misma función.

**Ejemplo (simulando un ciclo):**

```c
#include <stdio.h>

int main() {
    int i = 0;

bucle: // Esto es una etiqueta
    if (i < 5) {
        printf("%d ", i);
        i++;
        goto bucle; // Salta de vuelta a la etiqueta 'bucle'
    }
    printf("\nFin del ciclo.\n");

    return 0;
}
```

**Salida:**

```
0 1 2 3 4
Fin del ciclo.
```

Este código, aunque funciona, es mucho menos claro que un ciclo `for` o `while` estándar.

## El Problema con `goto`: Código Espagueti

El uso indiscriminado de `goto` puede llevar a lo que se conoce como **"código espagueti"**: un programa cuyo flujo de control es tan enrevesado y saltarín que se vuelve casi imposible de seguir, depurar y mantener.

```c
// ¡EJEMPLO DE MAL CÓDIGO! NO HACER ESTO.
if (cond1) goto seccionA;
// ...
seccionB:
    // ...
    if (cond3) goto seccionC;
    // ...
seccionA:
    // ...
    if (cond2) goto seccionB;
    // ...
seccionC:
    // ...
```

Un código así es una pesadilla. Las estructuras de control como `if`, `switch`, `while`, `for` y las funciones fueron diseñadas precisamente para proporcionar un flujo de control estructurado y predecible, eliminando la necesidad de `goto` en la mayoría de los casos.

## Usos Legítimos (y Raros) de `goto`

A pesar de su mala reputación, existen algunas situaciones muy específicas donde el uso de `goto` puede, argumentalmente, simplificar el código.

**El caso de uso más aceptado es para manejar la limpieza de recursos en una función con múltiples puntos de salida.**

Imagina una función que necesita abrir un archivo, alocar memoria y luego realizar varias operaciones que pueden fallar.

**Sin `goto`:**

```c
int funcion_compleja() {
    FILE *f = fopen("datos.txt", "r");
    if (f == NULL) {
        return -1; // Punto de salida 1
    }

    char *buffer = malloc(1024);
    if (buffer == NULL) {
        fclose(f); // Limpieza 1
        return -1; // Punto de salida 2
    }

    if (operacion_1(f, buffer) != 0) {
        free(buffer); // Limpieza 2
        fclose(f);    // Limpieza 1
        return -1; // Punto de salida 3
    }

    // ... más operaciones y más código de limpieza repetido ...

    free(buffer); // Limpieza final
    fclose(f);
    return 0; // Salida exitosa
}
```

El código de limpieza (`free(buffer)`, `fclose(f)`) se repite en cada punto de fallo.

**Con `goto`:**

```c
int funcion_compleja_con_goto() {
    int estado = -1; // Asumimos fallo por defecto

    FILE *f = fopen("datos.txt", "r");
    if (f == NULL) {
        goto cleanup_none;
    }

    char *buffer = malloc(1024);
    if (buffer == NULL) {
        goto cleanup_file;
    }

    if (operacion_1(f, buffer) != 0) {
        goto cleanup_buffer;
    }

    // Si todo va bien
    estado = 0;

cleanup_buffer:
    free(buffer);
cleanup_file:
    fclose(f);
cleanup_none:
    return estado;
}
```

En esta versión, toda la lógica de limpieza está centralizada en un solo lugar al final de la función. Si ocurre un error, se salta directamente a la sección de limpieza apropiada. Este patrón es común en el kernel de Linux y otro código de sistemas de bajo nivel.

## Comparación con JavaScript

JavaScript **no tiene una proposición `goto`**. El diseño del lenguaje fomenta un flujo de control estructurado. Para el manejo de errores y limpieza, JavaScript utiliza mecanismos como `try...catch...finally`, que cumplen un propósito similar de una manera mucho más estructurada y segura.

## Resumen

- `goto` permite saltos incondicionales a una etiqueta dentro de la misma función.
- **Regla general: Evítalo.** Su uso puede crear un "código espagueti" difícil de entender y mantener.
- Las estructuras de control estándar (`if`, `while`, `for`, `switch`) y las funciones son casi siempre una mejor alternativa.
- Su único uso legítimo y aceptado por algunos programadores es para centralizar la limpieza de recursos en funciones complejas con múltiples puntos de fallo, aunque incluso esto puede ser manejado de otras maneras.

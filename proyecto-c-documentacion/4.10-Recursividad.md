# 4.10. Recursividad

La **recursividad** o **recursión** es una poderosa técnica de programación en la que una función se llama a sí misma para resolver un problema. La idea central es descomponer un problema complejo en subproblemas más simples que son versiones más pequeñas del problema original, hasta llegar a un caso tan simple que se puede resolver directamente.

## Componentes de una Función Recursiva

Toda función recursiva bien diseñada debe tener dos componentes esenciales:

1.  **Caso Base:** Es la condición que detiene la recursividad. Es el subproblema más simple que se puede resolver sin necesidad de más llamadas recursivas. Sin un caso base, la función se llamaría a sí misma infinitamente, provocando un error de **desbordamiento de la pila** (_stack overflow_).

2.  **Paso Recursivo (o Caso Recursivo):** Es la parte de la función donde se llama a sí misma, pero con un argumento modificado que acerca el problema al caso base. La función utiliza el resultado de esta llamada para construir su propia solución.

## Ejemplo Clásico: El Factorial de un Número

El factorial de un entero no negativo `n`, denotado como `n!`, es el producto de todos los enteros positivos menores o iguales a `n`.

- `5! = 5 * 4 * 3 * 2 * 1 = 120`
- `3! = 3 * 2 * 1 = 6`
- `0! = 1` (por definición)

Podemos definir el factorial de forma recursiva:

- `n! = n * (n-1)!`
- `0! = 1`

**Implementación Recursiva:**

```c
#include <stdio.h>

long factorial(int n) {
    // Caso Base: Si n es 0 o 1, el factorial es 1.
    if (n <= 1) {
        return 1;
    }
    // Paso Recursivo: n * factorial del número anterior.
    else {
        return n * factorial(n - 1);
    }
}

int main() {
    int numero = 5;
    printf("El factorial de %d es %ld\n", numero, factorial(numero));
    return 0;
}
```

**Cómo funciona `factorial(4)`:**

1.  `factorial(4)` llama a `factorial(3)`. Devuelve `4 * resultado_de_factorial(3)`.
2.  `factorial(3)` llama a `factorial(2)`. Devuelve `3 * resultado_de_factorial(2)`.
3.  `factorial(2)` llama a `factorial(1)`. Devuelve `2 * resultado_de_factorial(1)`.
4.  `factorial(1)` alcanza el **caso base** y devuelve `1`.
5.  El `1` se devuelve a `factorial(2)`, que calcula `2 * 1 = 2`.
6.  El `2` se devuelve a `factorial(3)`, que calcula `3 * 2 = 6`.
7.  El `6` se devuelve a `factorial(4)`, que calcula `4 * 6 = 24`.

## Recursividad vs. Iteración

Cualquier problema que se puede resolver de forma recursiva también se puede resolver de forma iterativa (usando bucles como `for` o `while`).

**Factorial Iterativo:**

```c
long factorial_iterativo(int n) {
    long resultado = 1;
    for (int i = 2; i <= n; i++) {
        resultado *= i;
    }
    return resultado;
}
```

| Característica          | Recursividad                                                                                                  | Iteración                                                        |
| :---------------------- | :------------------------------------------------------------------------------------------------------------ | :--------------------------------------------------------------- |
| **Claridad del Código** | A menudo más elegante y cercano a la definición matemática del problema.                                      | Puede ser más verboso pero a veces más directo.                  |
| **Rendimiento**         | Generalmente más lento debido a la sobrecarga de las llamadas a función (crear un nuevo marco de pila, etc.). | Generalmente más rápido, sin sobrecarga de llamadas.             |
| **Uso de Memoria**      | Consume más memoria. Cada llamada recursiva añade un nuevo marco a la pila de llamadas.                       | Consume menos memoria (usualmente unas pocas variables locales). |
| **Riesgo**              | Desbordamiento de pila (_stack overflow_) si la recursividad es muy profunda.                                 | Bucles infinitos si la condición de terminación es incorrecta.   |

## ¿Cuándo usar Recursividad?

La recursividad es especialmente adecuada para problemas que tienen una naturaleza inherentemente recursiva, como:

- **Recorridos de estructuras de datos de árbol o grafo** (pre-orden, in-orden, post-orden).
- **Algoritmos de "divide y vencerás"** como Quicksort o Mergesort.
- **Problemas matemáticos** definidos recursivamente, como la secuencia de Fibonacci.

En estos casos, la solución recursiva suele ser mucho más simple, corta y fácil de entender que su contraparte iterativa.

## Comparación con JavaScript

La recursividad funciona conceptualmente de la misma manera en JavaScript. Sin embargo, hay una consideración de rendimiento: algunos motores de JavaScript implementan la **optimización de llamada de cola** (_tail call optimization_), que puede convertir ciertas formas de recursividad (recursividad de cola) en una iteración bajo el capó, evitando el desbordamiento de la pila. El estándar de C no garantiza esta optimización, aunque algunos compiladores modernos pueden realizarla.

## Resumen

- La recursividad es una técnica donde una función se llama a sí misma.
- Requiere un **caso base** para detenerse y un **paso recursivo** para acercarse al caso base.
- A menudo produce un código más elegante para problemas con estructura recursiva.
- Generalmente es menos eficiente en tiempo y memoria que una solución iterativa.
- Es crucial asegurarse de que el caso base siempre se alcance para evitar un desbordamiento de la pila.

# 4.11.2. Sustitución de Macros (`#define`)

La directiva `#define` es una de las herramientas más versátiles y potentes del preprocesador. Permite definir **macros**, que son esencialmente reglas de sustitución de texto. El preprocesador escanea el código fuente y reemplaza todas las ocurrencias del nombre de una macro por su definición antes de que el compilador vea el código.

Existen dos tipos principales de macros: macros tipo objeto y macros tipo función.

## Macros Tipo Objeto

Estas macros se usan comúnmente para definir **constantes simbólicas**. Asocian un identificador con un fragmento de código o un valor.

**Sintaxis:**
`#define NOMBRE_MACRO texto_de_reemplazo`

**Ejemplos:**

```c
#define PI 3.14159265
#define BUFFER_SIZE 1024
#define TRUE 1
#define FALSE 0
#define MENSAJE_ERROR "Error: Memoria insuficiente."
```

**Uso:**

```c
double circunferencia = 2 * PI * radio;
char mi_buffer[BUFFER_SIZE];
if (condicion_erronea) {
    puts(MENSAJE_ERROR);
}
```

**Ventajas:**

- **Legibilidad:** `BUFFER_SIZE` es más significativo que el "número mágico" `1024`.
- **Mantenimiento:** Si el tamaño del buffer necesita cambiar, solo se modifica la línea del `#define`, y el cambio se propaga a todo el código.

## Macros Tipo Función

Estas macros se parecen a las funciones, ya que pueden aceptar "argumentos". Sin embargo, la sustitución sigue siendo puramente textual.

**Sintaxis:**
`#define NOMBRE_MACRO(arg1, arg2, ...) texto_de_reemplazo`

**Ejemplo:**

```c
#define CUADRADO(x) ((x) * (x))
#define MAX(a, b) ((a) > (b) ? (a) : (b))
```

**Uso:**

```c
int area = CUADRADO(5); // Se expande a: int area = ((5) * (5));
int mayor = MAX(10, 20); // Se expande a: int mayor = ((10) > (20) ? (10) : (20));
```

## Peligros y Buenas Prácticas con Macros

Las macros son una herramienta poderosa pero peligrosa. Al ser una sustitución de texto ciega, pueden introducir errores sutiles si no se usan con cuidado.

### 1. Siempre usar Paréntesis

Es **esencial** encerrar cada argumento y la expresión completa de la macro entre paréntesis.

**Ejemplo del peligro:**

```c
#define CUADRADO_MALO(x) x * x

int resultado = CUADRADO_MALO(3 + 2);
// Expansión: int resultado = 3 + 2 * 3 + 2;
// Resultado incorrecto: 3 + 6 + 2 = 11 (en lugar de 5*5=25)

// Con la macro correcta CUADRADO((x)*(x))
int resultado_ok = CUADRADO(3 + 2);
// Expansión: int resultado_ok = ((3 + 2) * (3 + 2));
// Resultado correcto: 5 * 5 = 25
```

### 2. Cuidado con los Efectos Secundarios

Los argumentos de una macro pueden ser evaluados múltiples veces. Si un argumento tiene un efecto secundario (como `++` o `--`), el resultado puede ser inesperado.

**Ejemplo del peligro:**

```c
int x = 5;
int y = MAX(x++, 10);
// Expansión: int y = ((x++) > (10) ? (x++) : (10));
// 1. (x > 10) es falso. x se convierte en 6.
// 2. Se devuelve 10.
// 'y' termina siendo 10, pero 'x' se ha incrementado una vez.
// Si x fuera 11, (x++ > 10) sería verdadero, y x++ se ejecutaría de nuevo. ¡Un desastre!
```

**Regla de oro:** Nunca uses expresiones con efectos secundarios como argumentos de una macro.

### 3. Macros Multilínea

Se puede definir una macro que abarque varias líneas usando una barra invertida `\` al final de cada línea (excepto la última). Es una buena práctica encerrar macros multilínea en un bloque `do { ... } while(0)` para que se comporten como una sola proposición.

```c
#define IMPRIMIR_ERROR(msg) do { \
    fprintf(stderr, "Error: %s\n", msg); \
    exit(1); \
} while(0)
```

## `undef`

La directiva `#undef` permite "eliminar" la definición de una macro. A partir de ese punto, el nombre de la macro ya no será sustituido.

```c
#define MI_MACRO 100
// ... código que usa MI_MACRO ...
#undef MI_MACRO
// A partir de aquí, MI_MACRO ya no está definida.
```

## Comparación con Alternativas Modernas

- **Constantes Simbólicas:** Para constantes, usar `const` o `enum` es a menudo más seguro que `#define` porque respetan el alcance y el sistema de tipos.
  ```c
  const double PI = 3.14159; // Tiene tipo, respeta el alcance
  enum { BUFFER_SIZE = 1024 }; // Es una constante entera
  ```
- **Macros tipo Función:** Para funciones pequeñas, las **funciones `inline`** son una alternativa mucho más segura. Realizan la misma tarea (sugieren al compilador insertar el código en el lugar de la llamada para evitar la sobrecarga de la función) pero con todas las ventajas de una función real: comprobación de tipos, sin problemas de efectos secundarios y un espacio de nombres separado.

## Resumen

- `#define` crea macros que realizan sustituciones de texto antes de la compilación.
- Son útiles para constantes simbólicas y fragmentos de código repetitivos.
- **Deben usarse con extrema precaución:** siempre encerrar argumentos y la expresión completa entre paréntesis y nunca pasar argumentos con efectos secundarios.
- Para muchos casos de uso, las alternativas modernas como `const`, `enum` y las funciones `inline` son más seguras y preferibles.

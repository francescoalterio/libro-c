# 4.3. Variables Externas

Un programa en C puede estar compuesto por varias funciones distribuidas en diferentes archivos fuente. Una pregunta natural es: ¿cómo pueden estas funciones compartir datos? Una forma es a través de los argumentos de las funciones, pero esto puede volverse engorroso si muchas funciones necesitan acceso a un gran conjunto de datos comunes. La otra forma es mediante **variables externas**.

Una variable externa es, en esencia, una variable global. Su característica principal es que se define **fuera** de cualquier función, lo que le otorga un alcance que puede extenderse a lo largo de todo el programa, incluyendo múltiples archivos.

## Definición vs. Declaración

Para entender las variables externas, es crucial dominar la diferencia entre la **definición** y la **declaración** de una variable:

- **Definición:** Es donde la variable es creada y se le asigna almacenamiento. Ocurre **una sola vez** en todo el programa. Una definición puede incluir una inicialización.

  ```c
  int contador_global = 0; // Esto es una definición.
  ```

- **Declaración:** Es un anuncio que le dice al compilador las propiedades de una variable (su nombre y tipo), pero no le asigna almacenamiento. Su propósito es informar al compilador que la definición de esta variable existe en otro lugar. Se utiliza la palabra clave `extern`.
  ```c
  extern int contador_global; // Esto es una declaración.
  ```

## Uso a Través de Múltiples Archivos

Imaginemos un programa dividido en dos archivos: `main.c` y `utils.c`.

**`utils.c`**

```c
// --- Definición de las variables externas ---
// Se reserva memoria para ellas y se inicializan.
int contador = 0;
char buffer[100];

void incrementar_contador() {
    contador++;
}
```

**`main.c`**

```c
#include <stdio.h>

// --- Declaración de las variables externas ---
// Le decimos al compilador: "estas variables existen, están definidas
// en otro archivo. Confía en mí y déjame usarlas".
extern int contador;
extern char buffer[]; // No es necesario especificar el tamaño en la declaración extern

// Prototipo de la función que está en utils.c
void incrementar_contador();

int main() {
    printf("Contador inicial: %d\n", contador); // Accede a la variable externa

    incrementar_contador(); // Llama a la función que modifica la variable

    printf("Contador final: %d\n", contador); // El cambio se refleja aquí

    // Llenar el buffer
    sprintf(buffer, "Hola desde main");
    // ... otra función en otro archivo podría leer 'buffer' ...

    return 0;
}
```

**Para compilar este programa, se deben enlazar ambos archivos:**

```sh
gcc main.c utils.c -o mi_programa
```

**Flujo:**

1.  En `utils.c`, se **definen** `contador` y `buffer`. Se reserva memoria para ellas.
2.  En `main.c`, se **declaran** `contador` y `buffer` con `extern`. No se crea nueva memoria; simplemente se le informa al compilador sobre las variables existentes.
3.  `main` puede ahora leer y modificar `contador` y `buffer` directamente.
4.  Cuando `main` llama a `incrementar_contador`, la función en `utils.c` modifica su propia variable `contador`, y este cambio es visible de vuelta en `main`.

## ¿Cuándo usar Variables Externas?

El uso de variables externas debe ser limitado. Abusar de ellas puede llevar a un código fuertemente acoplado y difícil de mantener, donde no está claro qué función modifica qué dato y cuándo.

**Son apropiadas cuando:**

- Varios archivos fuente necesitan acceder a un conjunto de datos u objetos comunes (ej. una variable de configuración, un buffer de estado global).
- Se quiere evitar pasar un gran número de argumentos repetidamente a través de muchas capas de funciones.

**Alternativas:**

- Pasar punteros a las estructuras de datos como argumentos de función. Esto hace las dependencias de datos mucho más explícitas y es, a menudo, un mejor diseño.

## Comparación con JavaScript

- **Variables Globales en el Navegador:** En el JavaScript clásico que se ejecuta en un navegador, las variables declaradas en el ámbito global (fuera de cualquier función) se adjuntan al objeto `window`. Si incluyes varios archivos `<script>`, todos comparten el mismo ámbito global `window`, creando un efecto similar al de las variables externas en C. Esto se considera una mala práctica.
- **Módulos de ES6:** El JavaScript moderno utiliza un sistema de módulos (`import`/`export`). Una variable o función debe ser explícitamente **exportada** desde un archivo para que otro archivo pueda **importarla**. Este es un mecanismo mucho más seguro y explícito que las variables externas de C, ya que evita la contaminación del ámbito global y deja claras las dependencias entre archivos.

```javascript
// utils.js
export let contador = 0;
export function incrementar() {
  contador++;
}

// main.js
import { contador, incrementar } from "./utils.js";
console.log(contador); // 0
incrementar();
console.log(contador); // 1
```

## Resumen

- Las variables externas (globales) se definen fuera de cualquier función.
- La **definición** crea la variable y reserva memoria (se hace una vez).
- La **declaración** (`extern`) informa al compilador sobre una variable definida en otro lugar (se puede hacer en múltiples archivos).
- Permiten compartir datos entre funciones en diferentes archivos.
- Su uso debe ser meditado, ya que pueden crear dependencias ocultas y hacer el código más difícil de razonar. El sistema de módulos de JavaScript es un enfoque más moderno y seguro para el mismo problema.

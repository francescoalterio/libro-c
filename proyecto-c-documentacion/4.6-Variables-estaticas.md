# 4.6. Variables Estáticas

La palabra clave `static` es uno de los especificadores de almacenamiento en C. Su efecto depende del contexto en el que se utilice: dentro de una función (variable local) o fuera de todas las funciones (variable global o función). En ambos casos, `static` altera el **alcance** (visibilidad) o el **tiempo de vida** (duración) del identificador.

## 1. `static` en Variables Locales (Dentro de una Función)

Cuando se declara una variable local con `static`, su comportamiento cambia drásticamente:

- **Tiempo de Vida:** En lugar de ser una variable automática que se crea y destruye con cada llamada a la función, se convierte en una variable con **duración estática**. Esto significa que se crea y se inicializa **una sola vez** (a cero por defecto si no se inicializa explícitamente) al inicio del programa, y **conserva su valor entre llamadas sucesivas a la función**.
- **Alcance:** Su alcance sigue siendo **local** al bloque de la función. No puede ser accedida desde fuera de la función.

**Caso de uso principal:** Mantener un estado persistente dentro de una función sin exponer la variable globalmente.

**Ejemplo: Un contador de llamadas**

```c
#include <stdio.h>

void contar_llamadas() {
    // 'contador' se inicializa a 0 solo la primera vez.
    // En llamadas posteriores, conserva su valor anterior.
    static int contador = 0;
    contador++;
    printf("Esta función ha sido llamada %d veces.\n", contador);
}

int main() {
    contar_llamadas(); // Salida: ... 1 vez.
    contar_llamadas(); // Salida: ... 2 veces.
    contar_llamadas(); // Salida: ... 3 veces.
    return 0;
}
```

Sin `static`, `contador` se crearía y se inicializaría a 0 en cada llamada, y la salida siempre sería "1 vez".

## 2. `static` en Variables y Funciones Globales (Fuera de una Función)

Cuando `static` se aplica a una variable o función global (a nivel de archivo), su efecto es sobre el **alcance**:

- **Alcance:** Limita la visibilidad de la variable o función al **archivo fuente en el que fue declarada**. No puede ser accedida desde otros archivos, ni siquiera usando la palabra clave `extern`.
- **Tiempo de Vida:** Las variables globales ya tienen duración estática, por lo que `static` no cambia su tiempo de vida.

**Caso de uso principal:** Encapsulación. Permite crear "variables privadas" o "funciones de ayuda" para un módulo, que no forman parte de su interfaz pública y no pueden causar conflictos de nombres con otros módulos.

**Ejemplo: Módulo con una función de ayuda privada**

**`calculos.c`**

```c
#include <stdio.h>

// Esta función de ayuda es "privada" para calculos.c
// No puede ser llamada desde main.c
static double sumar_privado(double a, double b) {
    return a + b;
}

// Esta variable es "privada" para calculos.c
static int operaciones_realizadas = 0;

// Esta es la función pública que otros archivos pueden usar
double calcular_promedio(double x, double y) {
    operaciones_realizadas++;
    printf("Operaciones totales en este módulo: %d\n", operaciones_realizadas);
    double suma = sumar_privado(x, y);
    return suma / 2.0;
}
```

**`main.c`**

```c
#include <stdio.h>

// Prototipo de la función pública de calculos.c
double calcular_promedio(double x, double y);

// extern double sumar_privado(double, double); // ¡Esto daría un error del enlazador!
// extern int operaciones_realizadas;          // ¡Esto también daría un error!

int main() {
    double prom = calcular_promedio(10.0, 20.0);
    printf("El promedio es: %f\n", prom);

    prom = calcular_promedio(5.0, 3.0);
    printf("El promedio es: %f\n", prom);

    return 0;
}
```

Al compilar `gcc main.c calculos.c`, el programa funcionará perfectamente. `main` puede llamar a `calcular_promedio`, pero no tiene acceso a `sumar_privado` ni a `operaciones_realizadas`, lo que protege la implementación interna del módulo `calculos.c`.

## Comparación con JavaScript

- **`static` en funciones locales:** El concepto de una variable que persiste entre llamadas a una función se puede emular en JavaScript usando **clausuras (closures)**.
  ```javascript
  function crearContador() {
    let contador = 0; // Esta variable está "encerrada"
    return function () {
      contador++;
      console.log(`Llamada número ${contador}`);
    };
  }
  const contar = crearContador();
  contar(); // Llamada número 1
  contar(); // Llamada número 2
  ```
- **`static` en funciones/variables globales:** El concepto de limitar la visibilidad a un archivo es el comportamiento **por defecto** de los **módulos de ES6**. Todo lo que está en un archivo es privado para ese archivo a menos que se exporte explícitamente con `export`.

## Resumen

| Contexto                                 | Efecto de `static`                              | Propósito                                                |
| :--------------------------------------- | :---------------------------------------------- | :------------------------------------------------------- |
| **Variable Local** (en función)          | Cambia el tiempo de vida a **estático**.        | Mantener estado entre llamadas a la función.             |
| **Variable/Función Global** (en archivo) | Cambia el alcance a **interno** (solo archivo). | Encapsulación, crear miembros "privados" para un módulo. |

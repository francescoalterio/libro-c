# 4.8. Estructura de Bloques

En C, un **bloque** (o proposición compuesta) es una secuencia de declaraciones y proposiciones contenidas dentro de un par de llaves `{...}`. La estructura de bloques es una característica fundamental del lenguaje que va más allá de simplemente agrupar código; define el **alcance** y el **ciclo de vida** de las variables.

C no es un lenguaje "estructurado por bloques" en el mismo sentido que lenguajes como Algol o PL/I, donde las funciones y procedimientos podían anidarse. En C, **las funciones no se pueden definir dentro de otras funciones**. Sin embargo, las variables sí siguen reglas de alcance de bloque.

## Alcance de Bloque y Variables Automáticas

Como se vio en la sección de "Reglas de Alcance", cualquier variable declarada dentro de un bloque es **local** a ese bloque.

- **Creación y Destrucción:** Estas variables (llamadas **automáticas**) se crean cuando el flujo de control entra en el bloque y se destruyen cuando sale.
- **Visibilidad:** Solo son visibles dentro del bloque donde se declaran.

```c
void funcion() {
    int a = 1; // Alcance: toda la función

    if (a > 0) {
        int b = 2; // Alcance: solo este bloque if
        // 'a' y 'b' son visibles aquí
    }
    // 'b' ya no existe aquí

    for (int i = 0; i < 5; i++) { // 'i' tiene alcance de bloque (solo el for)
        // ...
    }
    // 'i' ya no existe aquí
}
```

## Bloques Independientes para Limitar el Alcance

No es necesario que un bloque esté asociado a una estructura de control como `if` o `for`. Puedes crear un bloque en cualquier parte de una función simplemente para crear un ámbito temporal.

**Caso de uso:** Limitar el ciclo de vida de una variable compleja o grande para liberar sus recursos lo antes posible, o para evitar colisiones de nombres.

```c
#include <stdio.h>

int main() {
    printf("Inicio del programa.\n");

    {
        // Este bloque crea un ámbito temporal
        int temp_var = 100;
        char buffer_grande[1024]; // Solo existe aquí
        printf("Dentro del bloque temporal, temp_var = %d\n", temp_var);
        // Realizar operaciones con buffer_grande...
    }

    // temp_var y buffer_grande ya no existen.
    // La memoria que ocupaban en la pila está disponible para otras variables.

    // printf("%d", temp_var); // ¡ERROR DE COMPILACIÓN!

    printf("Fin del programa.\n");
    return 0;
}
```

Este patrón es útil para gestionar la complejidad y el uso de memoria en funciones largas.

## Ocultamiento de Nombres (Shadowing)

La estructura de bloques permite el ocultamiento de nombres: una variable declarada en un bloque interno puede tener el mismo nombre que una variable en un bloque externo. Dentro del bloque interno, el nombre se referirá a la variable interna.

```c
int x = 1; // Global

void func() {
    int y = 2; // Local a func

    {
        int x = 3; // Oculta a la 'x' global
        int y = 4; // Oculta a la 'y' de func
        printf("Interno: x=%d, y=%d\n", x, y); // Imprime: Interno: x=3, y=4
    }

    printf("Externo: x=%d, y=%d\n", x, y); // Imprime: Externo: x=1, y=2
}
```

**Nota:** El `printf` externo imprime `x=1` porque, al no haber una `x` local en el ámbito de `func`, accede a la `x` global. Imprime `y=2` porque se refiere a la `y` declarada al inicio de `func`.

Aunque el lenguaje lo permite, el ocultamiento de nombres debe evitarse ya que hace que el código sea más difícil de leer y propenso a errores.

## Comparación con JavaScript

La estructura de bloques en JavaScript moderno es muy similar a la de C, gracias a la introducción de `let` y `const`.

- **`let` y `const`:** Crean variables con **alcance de bloque**, idéntico al de C.
  ```javascript
  let x = 1;
  if (true) {
    let x = 2; // Oculta a la x externa
    console.log(x); // 2
  }
  console.log(x); // 1
  ```
- **`var`:** Tiene **alcance de función**, lo que significa que no respeta los bloques de la misma manera. Una variable `var` declarada en cualquier lugar de una función es visible en toda la función. Este comportamiento es diferente al de C y es una de las razones por las que se prefiere `let` y `const` en el código moderno.

## Resumen

- La estructura de bloques `{...}` es la base del control de alcance en C.
- Las variables declaradas en un bloque son locales a ese bloque (variables automáticas).
- Se pueden crear bloques independientes para limitar el ciclo de vida de las variables y mejorar la gestión de la memoria y la claridad del código.
- Los bloques anidados pueden llevar al **ocultamiento de nombres**, una característica que debe usarse con precaución o evitarse.
- El comportamiento del alcance de bloque en C es muy similar al de `let` y `const` en JavaScript.

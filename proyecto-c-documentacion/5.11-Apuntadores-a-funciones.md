# 5.11. Apuntadores a Funciones

Así como los apuntadores pueden almacenar las direcciones de variables de datos, también pueden almacenar la **dirección de una función**. Esta capacidad permite una programación mucho más flexible y dinámica, habilitando patrones de diseño avanzados como los _callbacks_, las tablas de saltos (_jump tables_) y la implementación de ciertos tipos de polimorfismo.

Tratar a las funciones como datos que pueden ser pasados y almacenados es un concepto poderoso.

## Sintaxis

La sintaxis para declarar un apuntador a una función es una de las más complejas de C, pero se deriva lógicamente de la declaración de una función normal.

**Declaración de una función:**
`tipo_retorno nombre_funcion(tipo_arg1, tipo_arg2);`

**Declaración de un apuntador a esa función:**
`tipo_retorno (*nombre_apuntador)(tipo_arg1, tipo_arg2);`

**Desglose de la sintaxis del apuntador:**

- `tipo_retorno`: Debe coincidir con el tipo de retorno de las funciones a las que apuntará.
- `(*nombre_apuntador)`: El nombre del apuntador, precedido por un asterisco y **encerrado en paréntesis**. Los paréntesis son cruciales; sin ellos, `int *pf(int, int);` declararía una función llamada `pf` que devuelve un `int *`, no un apuntador a una función.
- `(tipo_arg1, tipo_arg2)`: La lista de tipos de los parámetros debe coincidir exactamente con la de las funciones a las que apuntará.

## Asignación y Llamada

- **Asignación**: Para asignar una función a un apuntador, simplemente se usa el nombre de la función. El nombre de una función, al igual que el de un arreglo, se convierte en un apuntador a sí misma en la mayoría de los contextos.
- **Llamada**: Se puede llamar a la función a través del apuntador usando una sintaxis que es idéntica a llamar a la función original.

### Ejemplo Básico

```c
#include <stdio.h>

int suma(int a, int b) {
    return a + b;
}

int resta(int a, int b) {
    return a - b;
}

int main() {
    // 'operacion_ptr' es un apuntador a una función que toma dos 'int' y devuelve un 'int'.
    int (*operacion_ptr)(int, int);

    // 1. Asignar la dirección de la función 'suma'.
    operacion_ptr = suma; // También es válido: operacion_ptr = &suma;

    // Llamar a 'suma' a través del apuntador.
    int resultado1 = operacion_ptr(10, 5); // Sintaxis moderna y preferida
    // int resultado1 = (*operacion_ptr)(10, 5); // Sintaxis antigua, también válida
    printf("Resultado de la suma: %d\n", resultado1); // Imprime 15

    // 2. Reasignar para que apunte a 'resta'.
    operacion_ptr = resta;

    // Llamar a 'resta' a través del mismo apuntador.
    int resultado2 = operacion_ptr(10, 5);
    printf("Resultado de la resta: %d\n", resultado2); // Imprime 5

    return 0;
}
```

## Caso de Uso: Arreglo de Apuntadores a Funciones (Tabla de Saltos)

Se puede crear un arreglo de apuntadores a funciones para implementar un menú o una máquina de estados de forma muy elegante, evitando largas cadenas de `if-else` o `switch`.

```c
#include <stdio.h>

void opcion_nuevo() { printf("-> Creando nuevo archivo...\n"); }
void opcion_abrir() { printf("-> Abriendo archivo...\n"); }
void opcion_guardar() { printf("-> Guardando archivo...\n"); }

// Arreglo de apuntadores a funciones que no reciben nada y no devuelven nada.
void (*menu_opciones[])() = {
    opcion_nuevo,
    opcion_abrir,
    opcion_guardar
};

int main() {
    int seleccion;
    printf("Elija una opción (0=Nuevo, 1=Abrir, 2=Guardar): ");
    scanf("%d", &seleccion);

    if (seleccion >= 0 && seleccion < 3) {
        // Llamar a la función correspondiente desde el arreglo.
        menu_opciones[seleccion]();
    } else {
        printf("Opción no válida.\n");
    }

    return 0;
}
```

## Comparación con JavaScript

En JavaScript, las **funciones son ciudadanos de primera clase**. Este es un concepto fundamental del lenguaje que significa que las funciones se pueden tratar como cualquier otro valor:

- Se pueden asignar a variables.
- Se pueden pasar como argumentos a otras funciones (_callbacks_).
- Se pueden devolver como resultado de otras funciones (cierres o _closures_).

```javascript
const suma = (a, b) => a + b;
const resta = (a, b) => a - b;

let operacion = suma; // Asignación directa
console.log(operacion(10, 5)); // 15

operacion = resta;
console.log(operacion(10, 5)); // 5

// Arreglo de funciones
const menuOpciones = [
  () => console.log("-> Creando nuevo archivo..."),
  () => console.log("-> Abriendo archivo..."),
  () => console.log("-> Guardando archivo..."),
];

const seleccion = 1;
if (seleccion >= 0 && seleccion < menuOpciones.length) {
  menuOpciones[seleccion](); // Llama a la función en el índice 1
}
```

La sintaxis en JavaScript es mucho más directa y el concepto está integrado de forma más natural en el lenguaje. Los apuntadores a funciones en C son el mecanismo de bajo nivel que permite emular este comportamiento de "funciones como datos".

## Resumen

- Un apuntador a función almacena la dirección de una función, permitiendo que sea tratada como una variable.
- La sintaxis `tipo_retorno (*puntero)(args)` es clave para declararlos correctamente.
- Son la base para implementar _callbacks_, tablas de funciones y otros patrones de diseño dinámicos.
- Son el análogo en C al concepto de "funciones de primera clase" de JavaScript, aunque con una sintaxis más explícita y compleja.

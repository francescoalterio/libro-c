# 5.2. Apuntadores y Argumentos de Funciones

Una de las aplicaciones más importantes de los apuntadores en C es su uso como argumentos de funciones. Por defecto, C pasa todos los argumentos a las funciones **por valor**. Esto significa que la función recibe una copia del valor del argumento, no el argumento original. Cualquier modificación a esa copia dentro de la función no afecta a la variable original en la función que la llamó.

Los apuntadores nos permiten simular el **paso por referencia**, dándole a una función la capacidad de modificar directamente las variables de la función llamante.

## ¿Cómo funciona el "Paso por Referencia"?

En lugar de pasar la variable misma, pasamos la **dirección de memoria** de esa variable. La función recibe esta dirección en un parámetro de tipo apuntador. Al desreferenciar este apuntador, la función puede acceder y modificar el valor original almacenado en esa dirección.

### Ejemplo Clásico: La Función `swap`

Una función para intercambiar los valores de dos variables es el ejemplo canónico para ilustrar este concepto.

**Intento fallido (paso por valor):**

```c
#include <stdio.h>

void swap_fallido(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    // 'a' y 'b' son copias locales. Sus valores se intercambian aquí,
    // pero las variables originales no se ven afectadas.
}

int main() {
    int x = 10, y = 20;
    printf("Antes: x = %d, y = %d\n", x, y);
    swap_fallido(x, y);
    printf("Después (fallido): x = %d, y = %d\n", x, y); // Imprime "x = 10, y = 20"
    return 0;
}
```

**Versión correcta (usando apuntadores):**

```c
#include <stdio.h>

// Los parámetros son apuntadores a enteros.
void swap_correcto(int *pa, int *pb) {
    int temp = *pa; // Obtiene el valor al que apunta 'pa'.
    *pa = *pb;      // Asigna el valor de 'pb' a la dirección de 'pa'.
    *pb = temp;     // Asigna el valor temporal a la dirección de 'pb'.
}

int main() {
    int x = 10, y = 20;
    printf("Antes: x = %d, y = %d\n", x, y);

    // Pasamos las direcciones de 'x' y 'y' a la función.
    swap_correcto(&x, &y);

    printf("Después (correcto): x = %d, y = %d\n", x, y); // Imprime "x = 20, y = 10"
    return 0;
}
```

En la versión correcta, `swap_correcto` recibe las direcciones de `x` y `y`. Al usar el operador de desreferencia `*`, la función manipula directamente los valores almacenados en esas direcciones de memoria, logrando el intercambio deseado.

## Paréntesis y Precedencia: `(*p)++` vs `*p++`

Cuando se combinan operadores como `*` y `++`, la precedencia es crucial.

- `(*p)++`: Primero desreferencia `p` (accede al valor) y luego incrementa **el valor**.
- `*p++`: Primero incrementa el apuntador `p` (haciendo que apunte a la siguiente dirección de memoria) y luego desreferencia la dirección _original_ de `p`. Los operadores `*` y `++` (postfijo) tienen la misma precedencia y se asocian de derecha a izquierda.

```c
void incrementar(int *p) {
    (*p)++; // Incrementa el valor en la dirección a la que p apunta.
}
```

## Comparación con JavaScript

El manejo de argumentos en JavaScript puede ser confuso, pero la regla es simple: **todo se pasa por valor**. La clave está en qué es "el valor".

- **Tipos Primitivos (Number, String, Boolean):** Se pasa una copia del valor. La función no puede modificar la variable original.

  ```javascript
  function cambiar(val) {
    val = 100; // Modifica la copia local.
  }
  let x = 10;
  cambiar(x);
  console.log(x); // 10
  ```

- **Objetos y Arreglos:** Se pasa una copia del **valor de la referencia** (la "dirección" del objeto). La función recibe una referencia que apunta al mismo objeto. Por lo tanto, la función **puede modificar las propiedades del objeto**, pero no puede reasignar la variable original a un objeto completamente nuevo.

  ```javascript
  function modificarObjeto(obj) {
    // Esto SÍ afecta al objeto original.
    obj.propiedad = "modificado";

    // Esto NO afecta a la variable original 'miObjeto'.
    // Solo reasigna la referencia local 'obj'.
    obj = { propiedad: "nuevo objeto" };
  }

  let miObjeto = { propiedad: "original" };
  modificarObjeto(miObjeto);
  console.log(miObjeto.propiedad); // "modificado"
  ```

## Resumen

- C pasa argumentos **por valor**.
- Para que una función modifique una variable de su llamante, debes pasar un **apuntador** a esa variable (su dirección `&var`).
- La función debe declarar el parámetro como un apuntador (`tipo *p`) y usar el operador de desreferencia (`*p`) para acceder o cambiar el valor original.
- Este mecanismo es explícito en C, mientras que en JavaScript el comportamiento similar con objetos es una consecuencia de cómo se manejan las referencias.

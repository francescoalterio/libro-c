# 5.4. Aritmética de Direcciones

La **aritmética de direcciones**, comúnmente conocida como **aritmética de apuntadores**, es una de las características que hacen a los apuntadores en C tan flexibles y potentes. Permite realizar operaciones aritméticas directamente sobre variables de tipo apuntador para navegar por la memoria, típicamente dentro de un arreglo.

La clave de la aritmética de apuntadores es que las operaciones son **escaladas automáticamente** por el compilador según el tamaño del tipo de dato al que apunta el apuntador.

## ¿Cómo funciona la Escala Automática?

Cuando sumas un entero `n` a un apuntador `p`, la dirección de memoria resultante no es `p + n` bytes. En cambio, es:

`p + n * sizeof(*p)`

Donde `sizeof(*p)` es el tamaño en bytes del tipo de dato al que `p` apunta.

- Si `p` es un `int *` (y `sizeof(int)` es 4), `p + 1` avanza la dirección en 4 bytes, apuntando al siguiente entero en la memoria.
- Si `p` es un `char *` (y `sizeof(char)` es 1), `p + 1` avanza la dirección en 1 byte, apuntando al siguiente carácter.
- Si `p` es un `double *` (y `sizeof(double)` es 8), `p + 1` avanza la dirección en 8 bytes, apuntando al siguiente double.

Esta escala automática es lo que permite que `*(p + i)` funcione correctamente para cualquier tipo de arreglo, ya que el compilador se encarga de calcular el desplazamiento correcto en bytes.

### Ejemplo de Recorrido de un Arreglo

```c
#include <stdio.h>

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    int *p = arr; // p apunta a arr[0]

    printf("Recorriendo el arreglo con aritmética de apuntadores:\n");

    for (int i = 0; i < 5; i++) {
        // p + i calcula la dirección del i-ésimo elemento.
        printf("Dirección: %p, Valor: %d\n", (void*)(p + i), *(p + i));
    }

    printf("\nUsando el operador de incremento ++:\n");
    // Al final del bucle anterior, p sigue apuntando a arr[0].
    for (int i = 0; i < 5; i++) {
        printf("Valor: %d\n", *p);
        p++; // p ahora apunta al siguiente elemento del arreglo.
    }
    // ¡Cuidado! Después de este bucle, 'p' apunta a una posición más allá del final del arreglo.

    return 0;
}
```

## Operaciones Válidas e Inválidas

No todas las operaciones aritméticas son válidas o tienen sentido con apuntadores.

### Operaciones Válidas

1.  **Sumar o restar un entero a un apuntador**: Resulta en un nuevo apuntador, desplazado `n` elementos hacia adelante o hacia atrás.

    - `p + n`
    - `p - n`
    - `p++`
    - `p--`

2.  **Restar dos apuntadores**: Si `p` y `q` apuntan a elementos del **mismo arreglo**, `p - q` devuelve el número de elementos que hay entre `p` y `q`. El resultado es un entero con signo (`ptrdiff_t`).

    - `int arr[10]; int *p = &arr[3]; int *q = &arr[7]; int diff = q - p; // diff será 4`

3.  **Comparar dos apuntadores**: Se pueden usar operadores relacionales (`<`, `>`, `==`, `!=`, etc.) para comparar dos apuntadores, siempre que apunten a elementos del mismo arreglo. Esto es útil para saber si un apuntador ha pasado a otro durante un recorrido.

### Operaciones Inválidas

- **Sumar dos apuntadores**: `p + q` no tiene ningún sentido lógico y es una operación ilegal. ¿Qué dirección representaría la suma de dos direcciones?
- **Multiplicar, dividir o realizar operaciones a nivel de bits** en apuntadores.
- Realizar aritmética con apuntadores que no apunten a un arreglo o a un bloque de memoria asignado (como con `malloc`). Hacerlo resulta en comportamiento indefinido.

## Comparación con JavaScript

El concepto de aritmética de direcciones **no existe en JavaScript**. La gestión de memoria en JS está completamente abstraída del programador.

- **Acceso por Índice**: En JS, siempre se accede a los elementos de un arreglo mediante su índice (`arr[i]`). No hay forma de obtener la dirección de memoria de un elemento ni de "avanzar un apuntador" al siguiente.
- **Seguridad de Memoria**: La ausencia de aritmética de apuntadores es una de las razones por las que JS es un lenguaje mucho más seguro en cuanto a memoria. Elimina toda una clase de errores comunes en C, como los desbordamientos de búfer (_buffer overflows_) o el acceso a memoria inválida.
- **Abstracción vs. Control**: C ofrece un control granular sobre la memoria a costa de la seguridad, mientras que JS prioriza la seguridad y la simplicidad a costa de ese control de bajo nivel.

## Resumen

- La aritmética de apuntadores es escalada por el compilador según el `sizeof` del tipo de dato apuntado.
- Permite una navegación eficiente por los arreglos y otras estructuras de datos en memoria.
- Las operaciones válidas incluyen sumar/restar enteros, y restar o comparar dos apuntadores del mismo arreglo.
- Es un concepto de bajo nivel sin un equivalente directo en lenguajes de alto nivel como JavaScript.

# 5.5. Apuntadores a Caracteres y Apuntadores a Funciones

Este tema cubre dos usos avanzados y potentes de los apuntadores: el manejo de cadenas de caracteres (la implementación de _strings_ en C) y la capacidad de tratar a las funciones como datos, permitiendo patrones de diseño complejos como los _callbacks_.

## Apuntadores a Caracteres (Cadenas en C)

En C, una "cadena" o _string_ no es un tipo de dato nativo. En su lugar, se representa como un **arreglo de caracteres** que termina con un carácter especial, el **carácter nulo** (`\0`). Un apuntador a `char` (`char *`) es la herramienta fundamental para trabajar con estas cadenas de manera eficiente.

Un `char *` puede apuntar al primer carácter de una cadena.

### Formas de Declarar Cadenas

1.  **Arreglo de Caracteres (Modificable):**

    ```c
    char mensaje_arreglo[] = "Hola Mundo";
    // Se reserva memoria en el stack (o en datos estáticos si es global).
    // El contenido del arreglo es una copia de la cadena y puede ser modificado.
    ```

2.  **Apuntador a un Literal de Cadena (Potencialmente no Modificable):**
    ```c
    char *p_mensaje = "Hola Mundo";
    // 'p_mensaje' es un apuntador que apunta a un "literal de cadena".
    // Estos literales suelen almacenarse en una sección de memoria de solo lectura.
    // Intentar modificarlo (ej. *p_mensaje = 'S';) resulta en comportamiento indefinido y a menudo falla.
    ```
    Esta segunda forma es más común para cadenas que no se van a alterar.

### Recorriendo una Cadena con un Apuntador

La aritmética de apuntadores es ideal para recorrer una cadena hasta encontrar el carácter nulo.

```c
#include <stdio.h>

void imprimir_cadena(char *s) {
    // El bucle continúa mientras el carácter al que apunta 's' no sea el carácter nulo.
    while (*s != '\0') {
        printf("%c", *s);
        s++; // Avanza el apuntador al siguiente carácter.
    }
    printf("\n");
}

int main() {
    char *cadena = "Esto es una prueba.";
    imprimir_cadena(cadena);
    return 0;
}
```

## Apuntadores a Funciones

Así como un apuntador puede almacenar la dirección de una variable, también puede almacenar la **dirección de una función**. Esto permite pasar funciones como argumentos a otras funciones, devolverlas o almacenarlas en estructuras de datos.

### Sintaxis de Declaración

La sintaxis para declarar un apuntador a función puede parecer compleja, pero sigue un patrón lógico:

`tipo_retorno (*nombre_apuntador)(lista_de_tipos_de_argumentos);`

- `tipo_retorno`: El tipo de dato que devuelve la función a la que se apuntará.
- `nombre_apuntador`: El nombre de nuestra variable de tipo apuntador. Los paréntesis `(*nombre_apuntador)` son cruciales.
- `lista_de_tipos_de_argumentos`: Los tipos de los parámetros que recibe la función.

**Ejemplo:**

```c
// 'pf' es un apuntador a una función que recibe dos enteros y devuelve un entero.
int (*pf)(int, int);
```

### Caso de Uso: Callbacks

Un _callback_ es una función que se pasa a otra función como argumento, para que la segunda la "llame de vuelta" (call back) cuando ocurra un evento o se complete una tarea.

```c
#include <stdio.h>

// Funciones que coinciden con la firma del apuntador
int sumar(int a, int b) { return a + b; }
int restar(int a, int b) { return a - b; }

// Esta función recibe dos enteros y un apuntador a función.
void ejecutar_operacion(int x, int y, int (*operacion)(int, int)) {
    int resultado = operacion(x, y); // Llama a la función a través del apuntador.
    printf("El resultado es: %d\n", resultado);
}

int main() {
    // Pasamos la función 'sumar' como argumento.
    printf("Ejecutando suma:\n");
    ejecutar_operacion(10, 5, sumar); // El nombre de la función actúa como un apuntador a ella.

    // Pasamos la función 'restar' como argumento.
    printf("Ejecutando resta:\n");
    ejecutar_operacion(10, 5, restar);

    return 0;
}
```

## Comparación con JavaScript

- **Cadenas**: JavaScript tiene un tipo de dato `string` primitivo y poderoso. Las cadenas en JS son **inmutables** (no se pueden cambiar una vez creadas) y vienen con una gran cantidad de métodos incorporados (`.slice()`, `.toUpperCase()`, etc.). Esto contrasta con las cadenas de C, que son simplemente arreglos de caracteres mutables y requieren funciones de biblioteca (`<string.h>`) para su manipulación.

- **Funciones de Primera Clase**: En JavaScript, las funciones son "ciudadanos de primera clase". Esto significa que se tratan como cualquier otro valor: se pueden asignar a variables, pasar como argumentos y devolver de otras funciones de forma natural y con una sintaxis simple. El concepto de _callback_ es central en la programación asíncrona de JavaScript.

  ```javascript
  function ejecutarOperacion(a, b, operacion) {
    const resultado = operacion(a, b);
    console.log(`El resultado es: ${resultado}`);
  }

  const sumar = (x, y) => x + y;
  const restar = (x, y) => x - y;

  ejecutarOperacion(10, 5, sumar); // Se pasa la función directamente.
  ejecutarOperacion(10, 5, restar);
  ```

  En C, los apuntadores a funciones logran un resultado similar, pero la sintaxis es más verbosa y el concepto está ligado al sistema de tipos y direcciones de memoria.

## Resumen

- Las cadenas en C son arreglos de caracteres terminados en `\0`, y se manipulan eficientemente con apuntadores `char *`.
- Los apuntadores a funciones almacenan la dirección de una función, permitiendo patrones de diseño dinámicos como los _callbacks_.
- Estos mecanismos de bajo nivel en C tienen equivalentes de más alto nivel y sintaxis más simple en JavaScript, que trata las cadenas como objetos inmutables y las funciones como ciudadanos de primera clase.

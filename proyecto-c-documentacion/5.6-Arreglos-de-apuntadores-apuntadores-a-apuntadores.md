# 5.6. Arreglos de Apuntadores y Apuntadores a Apuntadores

Estos son dos conceptos avanzados que se basan en las ideas fundamentales de los apuntadores. Permiten crear estructuras de datos más complejas y flexibles, como arreglos de cadenas de longitud variable o matrices dinámicas.

## Arreglos de Apuntadores

Como su nombre indica, un **arreglo de apuntadores** es un arreglo cuyos elementos, en lugar de ser `int`, `char` o `float`, son **apuntadores**. Cada elemento del arreglo almacena la dirección de memoria de algún otro dato.

Un caso de uso extremadamente común es un **arreglo de apuntadores a `char`** para manejar una lista de cadenas.

### Ejemplo: Arreglo de Cadenas

Imagina que necesitas almacenar los nombres de los días de la semana. Las cadenas "Lunes", "Martes", etc., tienen diferentes longitudes. Almacenarlas en una matriz bidimensional de `char` sería ineficiente, ya que cada fila tendría que tener el tamaño de la cadena más larga.

Un arreglo de apuntadores es la solución perfecta:

```c
#include <stdio.h>

int main() {
    // 'dias' es un arreglo de 7 elementos.
    // Cada elemento es de tipo 'char *' (apuntador a carácter).
    const char *dias[] = {
        "Lunes",
        "Martes",
        "Miércoles",
        "Jueves",
        "Viernes",
        "Sábado",
        "Domingo"
    };
    // Los literales de cadena se almacenan en memoria de solo lectura.
    // El arreglo 'dias' simplemente almacena las direcciones de inicio de cada una de estas cadenas.

    // Imprimir todos los días
    for (int i = 0; i < 7; i++) {
        printf("El día %d es %s\n", i + 1, dias[i]);
    }

    // Acceder a un carácter específico de una cadena
    // dias[2] es un 'char *' que apunta a "Miércoles"
    // *(dias[2] + 1) accede al segundo carácter ('i')
    printf("\nLa segunda letra de Miércoles es '%c'\n", *(dias[2] + 1));
    // O de forma más legible:
    printf("La segunda letra de Miércoles es '%c'\n", dias[2][1]);

    return 0;
}
```

Esta estructura es eficiente en memoria porque solo almacena los apuntadores y las cadenas exactas, sin desperdiciar espacio.

## Apuntadores a Apuntadores

Un **apuntador a un apuntador** (también llamado doble apuntador) es una variable que almacena la dirección de memoria de **otra variable de tipo apuntador**.

Se declaran usando dos asteriscos (`**`):

`tipo **nombre_apuntador;`

### Ejemplo Básico

```c
#include <stdio.h>

int main() {
    int x = 10;
    int *p = &x;      // p apunta a x. Almacena la dirección de x.
    int **pp = &p;    // pp apunta a p. Almacena la dirección de p.

    printf("Valor de x: %d\n", x);

    // Acceso a través de p
    printf("Valor usando *p: %d\n", *p);

    // Acceso a través de pp
    // *pp desreferencia una vez, dándonos el contenido de p (la dirección de x).
    // **pp desreferencia dos veces, dándonos el contenido de x (el valor 10).
    printf("Valor usando **pp: %d\n", **pp);

    printf("\n--- Direcciones ---\n");
    printf("Dirección de x (&x): %p\n", (void *)&x);
    printf("Dirección almacenada en p: %p\n", (void *)p);
    printf("Dirección de p (&p): %p\n", (void *)&p);
    printf("Dirección almacenada en pp: %p\n", (void *)pp);

    return 0;
}
```

### Casos de Uso Principales

1.  **Argumentos de la línea de comandos (`main`)**: La firma `int main(int argc, char *argv[])` es un ejemplo clásico. `argv` es un arreglo de apuntadores a `char`, donde cada apuntador señala a un argumento pasado al programa. La declaración `char *argv[]` es equivalente a `char **argv`.

2.  **Modificar un apuntador dentro de una función**: Si quieres que una función cambie a dónde apunta un apuntador que le pasas, debes pasar la dirección de ese apuntador (un apuntador al apuntador). Esto es común en funciones que asignan memoria dinámicamente.

    ```c
    void asignar_memoria(int **ptr) {
        *ptr = (int *)malloc(sizeof(int)); // Modifica el apuntador original.
    }

    int main() {
        int *mi_puntero = NULL;
        asignar_memoria(&mi_puntero); // Pasamos la dirección de 'mi_puntero'.
        if (mi_puntero != NULL) {
            *mi_puntero = 100;
            printf("Valor asignado: %d\n", *mi_puntero);
            free(mi_puntero);
        }
        return 0;
    }
    ```

3.  **Matrices Dinámicas**: Se pueden usar para crear matrices (arreglos 2D) cuyo tamaño se determina en tiempo de ejecución. Se asigna un arreglo de apuntadores, y luego, para cada apuntador, se asigna un arreglo de datos (una fila).

## Comparación con JavaScript

- **Arreglos de Arreglos**: El equivalente más cercano a un arreglo de apuntadores o una matriz en C es un **arreglo de arreglos** en JavaScript.

  ```javascript
  const dias = ["Lunes", "Martes", "Miércoles"]; // Arreglo de cadenas
  const matriz = [
    [1, 2],
    [3, 4],
  ]; // Arreglo de arreglos
  ```

  La diferencia fundamental es que JS maneja toda la gestión de memoria de forma automática. No hay un concepto explícito de "apuntador a un apuntador".

- **Paso por Referencia (Simulado)**: El caso de uso de modificar un apuntador en una función no tiene un análogo directo en JS. Como los objetos se pasan por referencia (de su valor), normalmente se modifica el contenido del objeto, o se devuelve un nuevo objeto de la función para reasignarlo fuera.

## Resumen

- Un **arreglo de apuntadores** es un arreglo donde cada elemento es un apuntador. Es ideal para listas de cadenas de diferentes tamaños.
- Un **apuntador a un apuntador** (`**`) almacena la dirección de otro apuntador.
- Los dobles apuntadores son cruciales para modificar apuntadores dentro de funciones, para los argumentos de `main`, y para crear estructuras de datos dinámicas como matrices 2D.
- Estos conceptos de manejo explícito de memoria en C son abstraídos en JavaScript a través de arreglos de arreglos y el manejo de referencias a objetos.

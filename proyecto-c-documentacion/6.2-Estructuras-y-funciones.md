# 6.2. Estructuras y Funciones

Las estructuras se vuelven realmente útiles cuando se combinan con funciones. Podemos pasar estructuras a funciones, ya sea por valor o por referencia (usando apuntadores), y las funciones también pueden devolver estructuras. La elección del método tiene implicaciones importantes en el rendimiento y en la capacidad de modificar los datos originales.

## Pasar Estructuras a Funciones

### 1. Paso por Valor

Cuando una estructura se pasa por valor, la función recibe una **copia completa** de la estructura original. Cualquier modificación realizada dentro de la función afecta a la copia, no a la variable original.

- **Ventaja**: Es seguro. La función no puede modificar accidentalmente los datos originales.
- **Desventaja**: Es ineficiente para estructuras grandes, ya que copiar todos los datos puede consumir tiempo y memoria en el stack.

**Ejemplo:**

```c
#include <stdio.h>

struct Punto { int x, y; };

// La función recibe una copia de la estructura 'Punto'.
void imprimir_punto(struct Punto p) {
    printf("Punto: (%d, %d)\n", p.x, p.y);
    p.x = 100; // Esto solo modifica la copia local.
}

int main() {
    struct Punto mi_punto = {10, 20};
    imprimir_punto(mi_punto);
    printf("Valor original después de la llamada: (%d, %d)\n", mi_punto.x, mi_punto.y); // Sigue siendo (10, 20)
    return 0;
}
```

### 2. Paso por Referencia (usando Apuntadores)

Este es el método más común y eficiente. En lugar de pasar la estructura completa, se pasa un **apuntador** a la estructura. La función recibe la dirección de memoria de la estructura original.

- **Ventaja**: Muy eficiente. Solo se copia una dirección de memoria (un apuntador), sin importar el tamaño de la estructura.
- **Ventaja**: Permite a la función **modificar la estructura original**.
- **Desventaja**: Menos seguro si no se desea la modificación. Se puede mitigar usando `const`.

#### El Operador Flecha (`->`)

Cuando se trabaja con un apuntador a una estructura, para acceder a sus miembros no se usa el operador punto (`.`). En su lugar, se utiliza el **operador flecha (`->`)**.

`apuntador_a_estructura->miembro`

Es simplemente "azúcar sintáctico" para `(*apuntador_a_estructura).miembro`. La forma con flecha es mucho más limpia y legible.

**Ejemplo:**

```c
#include <stdio.h>

struct Punto { int x, y; };

// La función recibe un apuntador a una estructura 'Punto'.
// 'const' indica que la función no modificará el contenido de la estructura.
void imprimir_punto_ptr(const struct Punto *p) {
    printf("Punto: (%d, %d)\n", p->x, p->y);
}

// Esta función sí modifica la estructura original.
void mover_punto(struct Punto *p, int dx, int dy) {
    p->x += dx;
    p->y += dy;
}

int main() {
    struct Punto mi_punto = {10, 20};

    imprimir_punto_ptr(&mi_punto); // Pasamos la dirección de la estructura.

    mover_punto(&mi_punto, 5, -5);
    printf("Punto después de mover: (%d, %d)\n", mi_punto.x, mi_punto.y); // Imprime (15, 15)

    return 0;
}
```

## Devolver Estructuras desde Funciones

Las funciones también pueden devolver una estructura. Esto es útil para funciones "constructoras" que crean e inicializan una estructura.

```c
#include <stdio.h>

struct Punto { int x, y; };

// Esta función devuelve una nueva estructura 'Punto'.
struct Punto crear_punto(int x, int y) {
    struct Punto nuevo_punto = {x, y};
    return nuevo_punto;
}

int main() {
    struct Punto p1 = crear_punto(100, 200);
    printf("Punto creado: (%d, %d)\n", p1.x, p1.y);
    return 0;
}
```

Al igual que con el paso de argumentos, devolver estructuras grandes por valor puede tener un coste de rendimiento, aunque los compiladores modernos a menudo optimizan este proceso (usando la _Return Value Optimization_ o RVO).

## Comparación con JavaScript

En JavaScript, la situación es más simple porque los objetos (el análogo a las `structs`) **siempre se pasan por referencia (de su valor)**.

```javascript
const punto = { x: 10, y: 20 };

function moverPunto(p, dx, dy) {
  // 'p' es una referencia al mismo objeto 'punto'.
  // Las modificaciones aquí afectan al objeto original.
  p.x += dx;
  p.y += dy;
}

moverPunto(punto, 5, -5);
console.log(punto); // { x: 15, y: 15 }
```

- **No hay elección**: En JS no se puede "pasar un objeto por valor" para obtener una copia automática. Para lograrlo, se debe clonar el objeto explícitamente dentro de la función (ej. usando `const copia = { ...p };`).
- **Sintaxis unificada**: Siempre se usa el operador punto (`.`) para acceder a las propiedades, ya que no hay un concepto explícito de apuntadores.

## Resumen

| Método en C                         | Cuándo Usarlo                                                                                 | Implicaciones                                                                                       |
| :---------------------------------- | :-------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------- |
| **Paso por Valor**                  | Con estructuras pequeñas o cuando la inmutabilidad es crucial y el rendimiento no es crítico. | Crea una copia completa. Seguro pero potencialmente lento.                                          |
| **Paso por Referencia (Apuntador)** | El método preferido en la mayoría de los casos, especialmente con estructuras grandes.        | Pasa solo una dirección. Eficiente y permite la modificación del original.                          |
| **Devolver por Valor**              | Para funciones "constructoras" que crean y devuelven nuevas instancias de estructuras.        | Crea una copia del valor de retorno. Conveniente pero puede ser lento para estructuras muy grandes. |

- El operador `.` se usa con variables de estructura.
- El operador `->` se usa con **apuntadores** a variables de estructura.

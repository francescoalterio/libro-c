# 6.3. Arreglos de Estructuras

Así como podemos tener arreglos de tipos básicos como `int` o `char`, también podemos crear **arreglos de estructuras**. Esta es una construcción extremadamente útil que nos permite manejar colecciones de objetos complejos, como una lista de contactos, un inventario de productos o un conjunto de coordenadas.

Un arreglo de estructuras es simplemente un arreglo donde cada elemento es una variable de tipo `struct`.

## Declaración e Inicialización

La declaración sigue la sintaxis estándar de los arreglos:

`struct nombre_estructura nombre_arreglo[TAMAÑO];`

La inicialización se puede hacer de forma similar a los arreglos multidimensionales, usando una lista de inicializadores entre llaves, donde cada inicializador interno corresponde a una estructura en el arreglo.

```c
#include <stdio.h>
#include <string.h>

struct Alumno {
    char nombre[50];
    int id_estudiante;
    float promedio;
};

int main() {
    // Declaración e inicialización de un arreglo de 3 estructuras 'Alumno'.
    struct Alumno clase_programacion[3] = {
        {"Ana Solís", 101, 8.5},
        {"Luis Castro", 102, 9.2},
        {"Marta Rivas", 103, 7.8}
    };

    // También se puede usar inicialización designada para mayor claridad.
    struct Alumno otra_clase[2] = {
        {.nombre = "Carlos Vera", .id_estudiante = 201, .promedio = 8.9},
        {.nombre = "Elena Mora", .id_estudiante = 202, .promedio = 9.5}
    };

    return 0;
}
```

## Acceso a Elementos y Miembros

Para acceder a una estructura específica dentro del arreglo, se usa el índice del arreglo. Una vez que se tiene el elemento (que es una estructura), se usa el operador punto (`.`) para acceder a sus miembros.

`nombre_arreglo[índice].nombre_miembro`

### Ejemplo de Uso

```c
#include <stdio.h>

struct Alumno {
    char nombre[50];
    int id_estudiante;
    float promedio;
};

int main() {
    struct Alumno clase[3] = {
        {"Ana Solís", 101, 8.5},
        {"Luis Castro", 102, 9.2},
        {"Marta Rivas", 103, 7.8}
    };

    // Imprimir la información de todos los alumnos
    printf("Lista de Alumnos:\n");
    for (int i = 0; i < 3; i++) {
        printf("  - Nombre: %s, ID: %d, Promedio: %.2f\n",
               clase[i].nombre,
               clase[i].id_estudiante,
               clase[i].promedio);
    }

    // Modificar un dato
    printf("\nActualizando el promedio de Luis...\n");
    clase[1].promedio = 9.4; // Luis está en el índice 1

    printf("Nuevo promedio de %s: %.2f\n", clase[1].nombre, clase[1].promedio);

    return 0;
}
```

## Arreglos de Estructuras y Funciones

Cuando se pasa un arreglo de estructuras a una función, se aplican las mismas reglas que con cualquier otro arreglo: lo que realmente se pasa es un **apuntador al primer elemento del arreglo**.

```c
// La función recibe un apuntador a la primera estructura del arreglo y el tamaño del arreglo.
void imprimir_clase(const struct Alumno clase[], int num_alumnos) {
    printf("Lista de Alumnos (desde la función):\n");
    for (int i = 0; i < num_alumnos; i++) {
        // Se puede usar la notación de arreglo o la de apuntador/flecha
        printf("  - Nombre: %s\n", clase[i].nombre);
        // Equivalente con apuntadores: printf("  - Nombre: %s\n", (clase + i)->nombre);
    }
}
```

- Usar `const` es una buena práctica si la función no debe modificar el arreglo.
- Es necesario pasar el tamaño del arreglo como un argumento separado, ya que la función por sí sola no puede saber cuántos elementos tiene.

## Comparación con JavaScript

El equivalente directo en JavaScript es un **arreglo de objetos**.

```javascript
const clase = [
  { nombre: "Ana Solís", id: 101, promedio: 8.5 },
  { nombre: "Luis Castro", id: 102, promedio: 9.2 },
  { nombre: "Marta Rivas", id: 103, promedio: 7.8 },
];

// Acceso y modificación son muy similares
console.log(clase[0].nombre); // "Ana Solís"
clase[1].promedio = 9.4;

// Iterar sobre el arreglo
clase.forEach((alumno) => {
  console.log(`${alumno.nombre} tiene un promedio de ${alumno.promedio}`);
});
```

**Diferencias Clave:**

- **Tamaño Fijo vs. Dinámico**: En C, un arreglo declarado de esta forma tiene un tamaño fijo establecido en tiempo de compilación. Para un tamaño dinámico, se necesitaría usar `malloc` para asignar memoria en el heap. En JavaScript, los arreglos son siempre dinámicos; se pueden añadir o quitar elementos fácilmente (`push`, `pop`, `splice`, etc.).
- **Homogeneidad**: En C, todos los elementos del arreglo deben ser del mismo tipo `struct`. En JavaScript, aunque es una buena práctica, un arreglo puede contener objetos con diferentes "formas" (propiedades).
- **Funcionalidades**: Los arreglos de JavaScript vienen con una rica biblioteca de métodos de alto nivel (`map`, `filter`, `reduce`, etc.) para la manipulación de datos, algo que en C se debe implementar manualmente con bucles.

## Resumen

- Un arreglo de estructuras permite gestionar colecciones de datos complejos y relacionados.
- La sintaxis para acceder a los miembros es `arreglo[indice].miembro`.
- Al pasarlos a funciones, se pasa un apuntador al primer elemento, por lo que se debe enviar el tamaño del arreglo por separado.
- Son el análogo de los arreglos de objetos en JavaScript, pero con las restricciones típicas de C: tamaño fijo (en el stack), tipado estricto y necesidad de implementación manual para operaciones complejas.

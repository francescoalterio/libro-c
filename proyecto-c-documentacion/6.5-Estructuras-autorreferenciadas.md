# 6.5. Estructuras Autorreferenciadas

Una **estructura autorreferenciada** es una estructura que contiene un miembro que es un **apuntador a una estructura de su mismo tipo**. Esta capacidad de "apuntar a sí misma" es la piedra angular para construir prácticamente todas las estructuras de datos dinámicas importantes, como listas enlazadas, árboles binarios, grafos, etc.

No es posible que una estructura contenga una instancia completa de sí misma como miembro, ya que esto crearía una definición recursiva de tamaño infinito.

```c
struct Nodo {
    int valor;
    struct Nodo otro_nodo; // ¡ILEGAL! Tamaño infinito.
};
```

Sin embargo, sí puede contener un **apuntador**, que siempre tiene un tamaño fijo y conocido.

## La Base de las Listas Enlazadas

El ejemplo más simple y fundamental de una estructura autorreferenciada es el nodo de una lista enlazada. Cada nodo contiene datos y un apuntador para "enlazar" con el siguiente nodo de la lista.

### Declaración del Nodo

```c
struct Nodo {
    int          dato;             // El dato que almacena el nodo.
    struct Nodo *siguiente;        // Apuntador al siguiente nodo en la lista.
};
```

- `dato`: Puede ser cualquier tipo de dato o incluso otra estructura.
- `siguiente`: Este es el miembro autorreferencial. Es un apuntador de tipo `struct Nodo *`, lo que le permite almacenar la dirección del próximo `struct Nodo`.

### Creando una Pequeña Lista Manualmente

Vamos a crear una lista simple con tres nodos para visualizar cómo se enlazan.

```c
#include <stdio.h>
#include <stdlib.h>

struct Nodo {
    int dato;
    struct Nodo *siguiente;
};

int main() {
    // Creamos tres nodos en el heap usando malloc.
    struct Nodo *cabeza = (struct Nodo *) malloc(sizeof(struct Nodo));
    struct Nodo *segundo = (struct Nodo *) malloc(sizeof(struct Nodo));
    struct Nodo *tercero = (struct Nodo *) malloc(sizeof(struct Nodo));

    // Verificación de malloc omitida por brevedad.

    // Inicializamos el primer nodo (cabeza).
    cabeza->dato = 10;
    cabeza->siguiente = segundo; // Enlazamos la cabeza con el segundo nodo.

    // Inicializamos el segundo nodo.
    segundo->dato = 20;
    segundo->siguiente = tercero; // Enlazamos el segundo con el tercero.

    // Inicializamos el tercer nodo.
    tercero->dato = 30;
    tercero->siguiente = NULL;   // El último nodo apunta a NULL para indicar el final de la lista.

    // Recorrer e imprimir la lista.
    printf("Lista enlazada:\n");
    struct Nodo *actual = cabeza;
    while (actual != NULL) {
        printf("%d -> ", actual->dato);
        actual = actual->siguiente; // Avanzamos al siguiente nodo.
    }
    printf("NULL\n");

    // Liberar la memoria.
    free(cabeza);
    free(segundo);
    free(tercero);

    return 0;
}
```

**Salida:**

```
Lista enlazada:
10 -> 20 -> 30 -> NULL
```

Este ejemplo demuestra cómo los apuntadores `siguiente` encadenan los nodos para formar una secuencia. El `NULL` final es crucial para saber dónde detenerse.

## Otras Estructuras de Datos

El mismo principio se extiende a estructuras más complejas:

- **Lista Doblemente Enlazada**: La estructura tendría dos apuntadores autorreferenciales: `*siguiente` y `*anterior`.

  ```c
  struct NodoDoble {
      int dato;
      struct NodoDoble *siguiente;
      struct NodoDoble *anterior;
  };
  ```

- **Árbol Binario**: La estructura tendría dos apuntadores para los hijos izquierdo y derecho.

  ```c
  struct NodoArbol {
      int dato;
      struct NodoArbol *izquierdo;
      struct NodoArbol *derecho;
  };
  ```

## Comparación con JavaScript

En JavaScript, los objetos pueden contener referencias a otros objetos de forma natural, lo que permite crear estructuras de datos similares sin la sintaxis explícita de apuntadores.

**Ejemplo de lista enlazada en JS:**

```javascript
class Nodo {
  constructor(dato) {
    this.dato = dato;
    this.siguiente = null;
  }
}

// Crear nodos
const cabeza = new Nodo(10);
const segundo = new Nodo(20);
const tercero = new Nodo(30);

// Enlazar nodos
cabeza.siguiente = segundo;
segundo.siguiente = tercero;

// Recorrer la lista
let actual = cabeza;
let resultado = "";
while (actual !== null) {
  resultado += `${actual.dato} -> `;
  actual = actual.siguiente;
}
resultado += "null";
console.log(resultado); // "10 -> 20 -> 30 -> null"
```

**Diferencias Clave:**

- **Gestión de Memoria**: En C, el programador es totalmente responsable de asignar (`malloc`) y liberar (`free`) la memoria para cada nodo. Un error aquí puede causar fugas de memoria (_memory leaks_). En JS, el recolector de basura se encarga de todo automáticamente.
- **Sintaxis y Tipado**: C requiere una declaración de tipo estricta (`struct Nodo *`) y el uso de apuntadores. JS es de tipado dinámico y utiliza referencias a objetos de forma más fluida.

## Resumen

- Las estructuras autorreferenciadas son aquellas que contienen un miembro que es un **apuntador a su mismo tipo de estructura**.
- Son el bloque de construcción fundamental para todas las **estructuras de datos dinámicas** (listas, árboles, grafos, etc.).
- Permiten que los elementos de datos se "enlacen" entre sí en la memoria, sin necesidad de estar en ubicaciones contiguas.
- El concepto es análogo a los objetos que se refieren entre sí en JavaScript, pero en C requiere una gestión manual y explícita de la memoria y los apuntadores.

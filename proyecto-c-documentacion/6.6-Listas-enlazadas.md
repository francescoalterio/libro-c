# 6.6. Listas Enlazadas

Una **lista enlazada** es una de las estructuras de datos más fundamentales en ciencias de la computación. Es una colección lineal de elementos de datos, llamados **nodos**, donde el orden no está determinado por su ubicación física en la memoria (como en un arreglo), sino por medio de apuntadores. Cada nodo contiene datos y un apuntador que "enlaza" al siguiente nodo de la secuencia.

Esta estructura es increíblemente flexible, especialmente para situaciones donde el número de elementos es desconocido o cambia con frecuencia.

## Ventajas sobre los Arreglos

| Característica            | Arreglos                                                                | Listas Enlazadas                                                                                                                     |
| :------------------------ | :---------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| **Tamaño**                | Fijo (estático). Debe definirse en tiempo de compilación.               | Dinámico. Crece y decrece según sea necesario en tiempo de ejecución.                                                                |
| **Inserción/Eliminación** | Ineficiente. Requiere desplazar elementos (operación O(n)).             | Muy eficiente. Solo requiere reajustar un par de apuntadores (operación O(1)), una vez localizado el punto de inserción/eliminación. |
| **Acceso a Elementos**    | Acceso aleatorio muy rápido (O(1)). `arreglo[i]` es un cálculo directo. | Acceso secuencial lento (O(n)). Para llegar al n-ésimo elemento, hay que recorrer los n-1 anteriores.                                |
| **Uso de Memoria**        | Puede desperdiciar memoria si se reserva más de la necesaria.           | Usa solo la memoria que necesita, pero cada nodo tiene una sobrecarga por el apuntador.                                              |

## Implementación de una Lista Enlazada Simple

Una implementación funcional de una lista enlazada requiere:

1.  La definición de la estructura del `Nodo`.
2.  Un apuntador a la `cabeza` (_head_) de la lista, que es el punto de entrada.
3.  Funciones para realizar operaciones comunes: insertar, eliminar, buscar, imprimir.

### Estructura del Nodo y la Lista

```c
#include <stdio.h>
#include <stdlib.h>

// El nodo autorreferenciado
struct Nodo {
    int dato;
    struct Nodo *siguiente;
};

// Un apuntador a la cabeza de la lista.
// Si la lista está vacía, cabeza es NULL.
struct Nodo *cabeza = NULL;
```

### Operaciones Comunes

**1. Insertar un nodo al principio:**
Esta es la operación de inserción más simple y rápida.

```c
void insertar_al_principio(int nuevo_dato) {
    // 1. Crear el nuevo nodo
    struct Nodo *nuevo_nodo = (struct Nodo*) malloc(sizeof(struct Nodo));
    nuevo_nodo->dato = nuevo_dato;

    // 2. El 'siguiente' del nuevo nodo apunta a la antigua cabeza
    nuevo_nodo->siguiente = cabeza;

    // 3. La cabeza de la lista es ahora el nuevo nodo
    cabeza = nuevo_nodo;
}
```

**2. Imprimir la lista:**
Recorre la lista desde la cabeza hasta el final (`NULL`).

```c
void imprimir_lista() {
    struct Nodo *actual = cabeza;
    while (actual != NULL) {
        printf("%d -> ", actual->dato);
        actual = actual->siguiente;
    }
    printf("NULL\n");
}
```

**3. Eliminar un nodo (por valor):**
Esta operación es más compleja. Debe manejar tres casos:

- La lista está vacía.
- El nodo a eliminar es la cabeza.
- El nodo a eliminar está en medio o al final.

```c
void eliminar_nodo(int dato_a_eliminar) {
    struct Nodo *actual = cabeza;
    struct Nodo *anterior = NULL;

    // Si la lista está vacía
    if (cabeza == NULL) return;

    // Buscar el nodo, manteniendo un registro del nodo anterior
    while (actual != NULL && actual->dato != dato_a_eliminar) {
        anterior = actual;
        actual = actual->siguiente;
    }

    // Si no se encontró el nodo
    if (actual == NULL) return;

    // Si el nodo a eliminar es la cabeza
    if (anterior == NULL) {
        cabeza = actual->siguiente;
    } else { // Si está en medio o al final
        anterior->siguiente = actual->siguiente;
    }

    free(actual); // Liberar la memoria del nodo eliminado
}
```

### Programa Principal de Ejemplo

```c
int main() {
    imprimir_lista(); // Lista vacía: NULL

    insertar_al_principio(10);
    insertar_al_principio(20);
    insertar_al_principio(30);
    imprimir_lista(); // 30 -> 20 -> 10 -> NULL

    eliminar_nodo(20);
    imprimir_lista(); // 30 -> 10 -> NULL

    eliminar_nodo(30); // Eliminar la cabeza
    imprimir_lista(); // 10 -> NULL

    return 0; // La memoria restante se liberaría en una implementación completa.
}
```

## Comparación con JavaScript

Aunque JavaScript no tiene una estructura de datos de "lista enlazada" nativa, sus `Array` son extremadamente potentes y optimizados, y cubren la mayoría de los casos de uso.

- **Arrays de JS**: Son dinámicos, permiten inserción y eliminación eficientes (`splice`, `push`, `pop`), y también ofrecen acceso rápido por índice. Están implementados de forma muy inteligente a bajo nivel para ofrecer lo mejor de ambos mundos en la mayoría de los escenarios.
- **Implementación Manual**: Se puede implementar una lista enlazada en JS usando clases u objetos, como se vio en la sección anterior. Esto puede ser útil en problemas de algoritmos muy específicos o para entender la estructura de datos, pero rara vez es necesario para el desarrollo de aplicaciones cotidianas.

## Resumen

- Una lista enlazada es una estructura de datos dinámica compuesta por **nodos** enlazados por **apuntadores**.
- Sobresale en **inserciones y eliminaciones eficientes** en cualquier parte de la lista.
- Su principal desventaja es el **acceso secuencial lento** a los elementos.
- La implementación requiere una gestión cuidadosa de la memoria (`malloc`/`free`) y de los apuntadores, especialmente el apuntador a la `cabeza` y los casos especiales (lista vacía, eliminación de la cabeza).
- Es un concepto fundamental en C, mientras que en JavaScript, los `Array` nativos suelen ser una alternativa más práctica y optimizada.

# 6.7. Estructuras como Argumentos de Función

La capacidad de pasar estructuras a funciones es fundamental para escribir código modular y organizado en C. Permite encapsular datos complejos y operar sobre ellos de manera limpia. Como se vio en la sección 6.2, existen dos métodos para hacerlo: **paso por valor** y **paso por referencia**. Esta sección profundiza en cuándo y por qué elegir cada uno.

## 1. Paso por Valor (Pasar una Copia)

En este método, la función recibe una copia completa de la estructura.

**Sintaxis:**
`void mi_funcion(struct MiEstructura var);`

```c
#include <stdio.h>

struct Rectangulo {
    int ancho;
    int alto;
};

// La función recibe una COPIA de la estructura.
int calcular_area(struct Rectangulo r) {
    // Cualquier cambio a 'r' aquí no afecta al original.
    // r.ancho = 0;
    return r.ancho * r.alto;
}

int main() {
    struct Rectangulo mi_rect = {10, 5};
    int area = calcular_area(mi_rect);
    printf("El área es: %d\n", area);
    printf("El ancho original no ha cambiado: %d\n", mi_rect.ancho);
    return 0;
}
```

### Ventajas y Desventajas del Paso por Valor

- **Ventaja - Seguridad (Inmutabilidad):** Es la forma más segura de pasar datos si la función solo necesita leerlos. Garantiza que la función no pueda modificar accidentalmente la estructura original. Es ideal para funciones que realizan cálculos y devuelven un resultado sin efectos secundarios.
- **Desventaja - Rendimiento:** Es ineficiente para estructuras grandes. Copiar una estructura de muchos bytes en el stack de la función en cada llamada puede ralentizar el programa y consumir mucha memoria.

**¿Cuándo usarlo?**
Úsalo solo con estructuras muy pequeñas (que contengan unos pocos `int` o `float`) y cuando la seguridad de que los datos no serán modificados sea la máxima prioridad.

## 2. Paso por Referencia (Pasar un Apuntador)

Este es el método más común y, por lo general, el preferido. En lugar de la estructura completa, se pasa su dirección de memoria (un apuntador).

**Sintaxis:**
`void mi_funcion(struct MiEstructura *ptr);`

```c
#include <stdio.h>

struct Rectangulo {
    int ancho;
    int alto;
};

// La función recibe un APUNTADOR a la estructura.
void escalar_rectangulo(struct Rectangulo *r, int factor) {
    // Usamos '->' para acceder a los miembros a través del apuntador.
    // Los cambios aquí SÍ afectan a la estructura original.
    r->ancho *= factor;
    r->alto *= factor;
}

int main() {
    struct Rectangulo mi_rect = {10, 5};
    printf("Dimensiones originales: %d x %d\n", mi_rect.ancho, mi_rect.alto);

    escalar_rectangulo(&mi_rect, 2); // Pasamos la dirección de 'mi_rect'.

    printf("Dimensiones escaladas: %d x %d\n", mi_rect.ancho, mi_rect.alto);
    return 0;
}
```

### El Modificador `const` para Seguridad

Una preocupación del paso por referencia es que la función puede modificar los datos. Si queremos la eficiencia de un apuntador pero la seguridad del paso por valor, podemos usar el calificador `const`.

`void mi_funcion_segura(const struct MiEstructura *ptr);`

`const` le promete al compilador (y a otros programadores) que la función no cambiará el contenido de la estructura a la que apunta `ptr`. Si el código de la función intenta hacerlo, el compilador generará un error.

```c
// Esta función solo lee datos, por lo que 'const' es apropiado.
void imprimir_dimensiones(const struct Rectangulo *r) {
    // r->ancho = 0; // ¡Esto generaría un error de compilación!
    printf("Dimensiones: %d x %d\n", r->ancho, r->alto);
}
```

### Ventajas y Desventajas del Paso por Referencia

- **Ventaja - Rendimiento:** Extremadamente eficiente. Solo se copia un apuntador (típicamente 4 u 8 bytes), sin importar el tamaño de la estructura.
- **Ventaja - Flexibilidad:** Permite a la función modificar la estructura original, lo cual es necesario para muchas operaciones.
- **Desventaja - Seguridad (si no se usa `const`):** La función puede modificar los datos, lo que podría no ser deseable. Este riesgo se mitiga con `const`.

## Comparación con JavaScript

Este es un punto clave de divergencia entre C y JavaScript.

- **C te da a elegir:** Puedes decidir explícitamente si quieres una copia (paso por valor) o un enlace al original (paso por referencia con apuntadores). Esta elección te da un control preciso sobre la memoria y el comportamiento.
- **JavaScript decide por ti:** Los objetos (el análogo a las `structs`) **siempre** se pasan de una manera que se comporta como el paso por referencia. No hay una forma nativa de pasar un objeto y obtener una copia automática; la función siempre recibe una referencia al objeto original.

```javascript
const miRect = { ancho: 10, alto: 5 };

function escalarRectangulo(r, factor) {
  // 'r' es una referencia al objeto 'miRect'.
  // Los cambios aquí afectan al original.
  r.ancho *= factor;
  r.alto *= factor;
}

escalarRectangulo(miRect, 2);
console.log(miRect); // { ancho: 20, alto: 10 }
```

## Resumen

- **Paso por Valor**: Crea una copia. Es seguro pero ineficiente para estructuras grandes. Úsalo para estructuras pequeñas cuando no necesites modificar el original.
- **Paso por Referencia**: Pasa un apuntador. Es rápido y permite la modificación. Es el método preferido para la mayoría de los casos.
- Usa `const` con apuntadores para obtener la eficiencia del paso por referencia y la seguridad del paso por valor.
- La elección explícita en C contrasta con el comportamiento fijo de "paso por referencia" de los objetos en JavaScript.

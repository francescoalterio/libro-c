# 6.8. Estructuras como Valores de Retorno

Así como las estructuras pueden ser pasadas como argumentos a funciones, también pueden ser **devueltas como valor de retorno**. Esta es una técnica muy poderosa que permite a una función devolver múltiples valores agrupados lógicamente, superando la limitación de que una función solo puede tener un único valor de retorno.

## ¿Cómo Funciona?

Cuando una función se declara para que devuelva un tipo `struct`, al ejecutar la sentencia `return`, se crea una copia de la estructura y se pasa de vuelta a la función que la llamó.

**Sintaxis de la declaración de la función:**
`struct MiEstructura nombre_funcion(parametros...);`

### Ejemplo: Función "Constructora"

Una de las aplicaciones más comunes es crear funciones que actúan como "constructores": toman algunos valores iniciales y devuelven una nueva estructura completamente inicializada.

```c
#include <stdio.h>

struct Punto {
    int x;
    int y;
};

// Esta función toma dos enteros y devuelve una estructura Punto.
struct Punto crear_punto(int x, int y) {
    struct Punto nuevo_punto; // Crea una instancia local.

    nuevo_punto.x = x;
    nuevo_punto.y = y;

    // Devuelve una copia de la estructura local.
    return nuevo_punto;
}

int main() {
    // La variable 'p1' recibe la copia de la estructura devuelta por la función.
    struct Punto p1 = crear_punto(10, 20);

    printf("Punto creado en (%d, %d)\n", p1.x, p1.y);

    // Se puede usar directamente en otra expresión.
    struct Punto p2 = crear_punto(p1.x + 5, p1.y - 5);
    printf("Punto p2 está en (%d, %d)\n", p2.x, p2.y);

    return 0;
}
```

## Consideraciones de Rendimiento

Al igual que con el paso de argumentos por valor, devolver una estructura por valor implica **crear una copia**. Para estructuras pequeñas, esto es perfectamente aceptable y conduce a un código muy limpio y legible.

Sin embargo, para estructuras muy grandes, esta copia puede ser costosa en términos de rendimiento. En tales casos, existe una técnica alternativa:

### Alternativa: Pasar un Apuntador para ser "Llenado"

En lugar de que la función devuelva la estructura, se puede pasar un apuntador a una estructura (que ya existe en la función llamante) y la función se encarga de "llenar" sus datos.

```c
#include <stdio.h>

struct DatosGrandes {
    double data[1000]; // Una estructura grande
};

// Esta función no devuelve nada (void), pero modifica la estructura
// a través del apuntador que recibe.
void inicializar_datos(struct DatosGrandes *d) {
    for (int i = 0; i < 1000; i++) {
        d->data[i] = i * 1.1;
    }
}

int main() {
    struct DatosGrandes mis_datos; // La estructura se crea en el stack de main.

    // Pasamos la dirección de la estructura para que la función la llene.
    inicializar_datos(&mis_datos);

    printf("El primer dato es: %f\n", mis_datos.data[0]);
    printf("El último dato es: %f\n", mis_datos.data[999]);

    return 0;
}
```

Esta alternativa es mucho más eficiente para estructuras grandes, ya que evita la copia completa. La desventaja es que el código puede ser un poco menos directo que una simple asignación `variable = funcion();`.

**Optimización del Valor de Retorno (RVO):**
Vale la pena mencionar que los compiladores modernos son muy inteligentes. A menudo pueden aplicar una optimización llamada **Return Value Optimization (RVO)**, que elimina la copia innecesaria al devolver una estructura, haciendo que el código legible (devolver por valor) sea tan eficiente como el código que pasa un apuntador. Sin embargo, no está garantizado que esta optimización ocurra siempre.

## Comparación con JavaScript

En JavaScript, devolver un objeto desde una función es una práctica extremadamente común y natural.

```javascript
function crearPunto(x, y) {
  // Se puede devolver un objeto literal directamente.
  return { x: x, y: y };
}

// Sintaxis de desestructuración para asignar los valores a variables.
const { x, y } = crearPunto(10, 20);
console.log(`Punto creado en (${x}, ${y})`);

// O simplemente guardar el objeto devuelto.
const p1 = crearPunto(30, 40);
console.log(p1.x); // 30
```

- **Sintaxis Literal**: JS permite crear y devolver objetos "al vuelo" con la sintaxis de objeto literal (`{}`), lo cual es muy conciso.
- **Gestión de Referencias**: La función devuelve una referencia al nuevo objeto creado. La gestión de la memoria es automática. No hay una distinción de rendimiento tan marcada entre devolver un objeto o modificar uno pasado como argumento, ya que en ambos casos se manejan referencias.

## Resumen

- Las funciones en C pueden devolver estructuras, lo que permite retornar múltiples valores de forma encapsulada.
- **Devolver por valor** es simple y legible, ideal para funciones "constructoras" y estructuras pequeñas.
- Para **estructuras grandes**, devolver por valor puede ser ineficiente. La alternativa es **pasar un apuntador** a la función para que esta "llene" la estructura.
- La elección entre estos métodos es un clásico equilibrio en C entre la **claridad del código y el rendimiento**.
- En JavaScript, devolver objetos es una operación natural y eficiente gracias a la sintaxis de objetos literales y la gestión automática de referencias.

# 6.9. Tipos `union`

Una **unión** (`union`) es un tipo de dato especial en C que permite almacenar diferentes tipos de datos en la **misma ubicación de memoria**. A primera vista, su declaración es similar a la de una `struct`, pero su comportamiento es fundamentalmente diferente.

Mientras que una `struct` reserva espacio para _todos_ sus miembros, una `union` solo reserva espacio suficiente para su **miembro más grande**. Todos los miembros de una unión comparten ese mismo espacio de memoria.

Esto implica que **solo se puede almacenar un valor en un miembro de la unión a la vez**. Si se asigna un valor a un miembro, y luego se asigna un valor a otro miembro, el primer valor se corrompe.

## Declaración y Uso

La sintaxis de declaración es idéntica a la de una `struct`, pero usando la palabra clave `union`.

```c
#include <stdio.h>

union Dato {
    int   i;
    float f;
    char  str[20];
};

int main() {
    union Dato dato;

    printf("Tamaño de la unión 'Dato': %zu bytes\n", sizeof(dato));
    // El tamaño será el del miembro más grande, en este caso, char str[20].

    // 1. Almacenar y usar un entero
    dato.i = 10;
    printf("dato.i: %d\n", dato.i);

    // 2. Almacenar y usar un flotante
    // ¡Esto SOBRESCRIBE el valor de dato.i!
    dato.f = 220.5;
    printf("dato.f: %f\n", dato.f);
    // En este punto, leer dato.i daría un valor basura.
    // printf("dato.i después de escribir f: %d\n", dato.i); // Comportamiento indefinido

    // 3. Almacenar y usar una cadena
    // ¡Esto SOBRESCRIBE el valor de dato.f!
    strcpy(dato.str, "Hola Mundo");
    printf("dato.str: %s\n", dato.str);

    return 0;
}
```

## ¿Por qué usar una `union`?

Las uniones pueden parecer extrañas, pero tienen casos de uso importantes, principalmente relacionados con la eficiencia de la memoria y la manipulación de datos a bajo nivel.

### 1. Ahorro de Memoria

El caso de uso más común es cuando se necesita una variable que puede contener diferentes tipos de datos, pero se sabe que **nunca los contendrá simultáneamente**.

Imaginemos una estructura para un paquete de red que puede contener diferentes tipos de carga útil:

```c
struct Paquete {
    int tipo_paquete; // 0=texto, 1=codigo_error, 2=valor_numerico
    union CargaUtil {
        char texto[128];
        int  codigo_error;
        double valor_numerico;
    } carga;
};
```

Sin una `union`, tendríamos que incluir los tres campos en la estructura, reservando `128 + sizeof(int) + sizeof(double)` bytes para la carga útil, aunque solo usemos uno a la vez. Con la `union`, el tamaño de `carga` es solo el de su miembro más grande (`char texto[128]`), ahorrando una cantidad significativa de memoria por cada paquete.

Para saber qué miembro de la unión está activo, se usa una variable externa, como `tipo_paquete`. Esto se conoce como **unión etiquetada** o **unión discriminada**.

```c
void procesar_paquete(struct Paquete p) {
    switch (p.tipo_paquete) {
        case 0:
            printf("Texto: %s\n", p.carga.texto);
            break;
        case 1:
            printf("Código de error: %d\n", p.carga.codigo_error);
            break;
        case 2:
            printf("Valor numérico: %f\n", p.carga.valor_numerico);
            break;
    }
}
```

### 2. Interpretación de Tipos (Type Punning)

Un uso más avanzado (y potencialmente peligroso) es para la reinterpretación de los bits de un tipo de dato como si fueran de otro tipo. Por ejemplo, para examinar la representación binaria de un `float`. Esto depende del hardware y puede no ser portable.

## Comparación con JavaScript

El concepto de `union` **no tiene un equivalente directo en JavaScript**, ya que el lenguaje está diseñado con un enfoque de más alto nivel y no para la gestión manual de la memoria.

- **Tipado Dinámico**: En JavaScript, una variable puede contener cualquier tipo de dato, y su tipo puede cambiar durante la ejecución.

  ```javascript
  let dato = 10; // dato es un número
  dato = "Hola Mundo"; // ahora es una cadena
  dato = { valor: 20 }; // ahora es un objeto
  ```

  Esta flexibilidad inherente del tipado dinámico de JS elimina la necesidad de una construcción como `union` para almacenar diferentes tipos en la misma "variable".

- **Gestión de Memoria**: JavaScript gestiona la memoria automáticamente. El programador no necesita preocuparse por optimizar el uso de memoria de la misma manera que en C.

- **Uniones Discriminadas**: El patrón de "unión etiquetada" se puede simular en JS usando objetos con una propiedad de tipo:

  ```javascript
  const paqueteTexto = { tipo: "TEXTO", carga: "Hola" };
  const paqueteError = { tipo: "ERROR", carga: 404 };

  function procesarPaquete(p) {
    switch (p.tipo) {
      case "TEXTO":
        console.log(`Texto: ${p.carga}`);
        break;
      case "ERROR":
        console.log(`Error: ${p.carga}`);
        break;
    }
  }
  ```

## Resumen

- Una `union` es un tipo de dato que permite que múltiples miembros **compartan la misma ubicación de memoria**.
- Su tamaño es el del miembro más grande.
- Solo un miembro puede estar "activo" a la vez; escribir en uno corrompe los demás.
- Su principal caso de uso es el **ahorro de memoria** cuando una variable necesita contener diferentes tipos de datos, pero nunca al mismo tiempo (uniones etiquetadas).
- Es un concepto de bajo nivel para la gestión de memoria que no tiene un análogo directo en lenguajes de alto nivel y tipado dinámico como JavaScript.

# 7.3. Lectura y Escritura de Archivos

Una vez que un archivo está abierto, C ofrece una variedad de funciones para leer y escribir datos. La elección de la función depende del tipo de datos que se esté manejando: caracteres individuales, líneas de texto, datos con formato o bloques de datos binarios.

## E/S de Caracteres: `fgetc()` y `fputc()`

Estas son las funciones más básicas para leer y escribir un carácter a la vez.

- `int fgetc(FILE *flujo)`: Lee el siguiente carácter del flujo y lo devuelve como un `int`. Devuelve `EOF` (End Of File) si se llega al final del archivo o si ocurre un error.
- `int fputc(int caracter, FILE *flujo)`: Escribe el `caracter` en el flujo. Devuelve el carácter escrito si tiene éxito, o `EOF` si falla.

**Ejemplo: Copiar un archivo carácter por carácter**

```c
#include <stdio.h>

int main() {
    FILE *origen = fopen("origen.txt", "r");
    FILE *destino = fopen("destino.txt", "w");
    int c;

    if (origen == NULL || destino == NULL) {
        perror("Error al abrir archivos");
        return 1;
    }

    // Lee un carácter de 'origen' y lo escribe en 'destino'
    // hasta que fgetc devuelva EOF.
    while ((c = fgetc(origen)) != EOF) {
        fputc(c, destino);
    }

    printf("Archivo copiado exitosamente.\n");
    fclose(origen);
    fclose(destino);
    return 0;
}
```

## E/S de Líneas: `fgets()` y `fputs()`

Estas funciones son ideales para trabajar con archivos de texto línea por línea.

- `char *fgets(char *buffer, int tamano, FILE *flujo)`: Lee una línea del `flujo` y la almacena en `buffer`. Deja de leer después de `tamano - 1` caracteres, o después de un carácter de nueva línea `\n` (que también se almacena), o al llegar a `EOF`. Devuelve `buffer` si tiene éxito, o `NULL` al final del archivo o en caso de error.
- `int fputs(const char *cadena, FILE *flujo)`: Escribe la `cadena` en el `flujo`. No añade un `\n` automáticamente.

**Ejemplo: Leer un archivo línea por línea**

```c
#include <stdio.h>

int main() {
    FILE *archivo = fopen("mi_documento.txt", "r");
    char linea[256]; // Búfer para almacenar cada línea

    if (archivo == NULL) {
        perror("Error");
        return 1;
    }

    printf("Contenido del archivo:\n");
    // fgets devuelve NULL cuando ya no hay más líneas que leer.
    while (fgets(linea, sizeof(linea), archivo) != NULL) {
        printf("%s", linea); // Imprime la línea (ya incluye el \n)
    }

    fclose(archivo);
    return 0;
}
```

## E/S con Formato: `fscanf()` y `fprintf()`

Estas funciones son las versiones para archivos de `scanf()` y `printf()`. Permiten leer y escribir datos con un formato específico, convirtiéndolos entre su representación textual en el archivo y su representación en memoria.

- `int fprintf(FILE *flujo, const char *formato, ...)`: Escribe datos en el `flujo` según la cadena de `formato`.
- `int fscanf(FILE *flujo, const char *formato, ...)`: Lee datos del `flujo`, los interpreta según la cadena de `formato` y los almacena en las direcciones de memoria proporcionadas.

**Ejemplo: Guardar y leer datos de un inventario**

```c
#include <stdio.h>

int main() {
    FILE *f_inventario;
    char nombre[50];
    int cantidad;
    float precio;

    // Escribir datos con formato en el archivo
    f_inventario = fopen("inventario.txt", "w");
    fprintf(f_inventario, "Tornillos 100 0.05\n");
    fprintf(f_inventario, "Tuercas 150 0.03\n");
    fclose(f_inventario);

    // Leer datos con formato del archivo
    f_inventario = fopen("inventario.txt", "r");
    printf("Inventario:\n");
    // fscanf devuelve el número de items leídos con éxito.
    while (fscanf(f_inventario, "%s %d %f", nombre, &cantidad, &precio) == 3) {
        printf("  - Producto: %s, Cantidad: %d, Precio: %.2f\n", nombre, cantidad, precio);
    }
    fclose(f_inventario);

    return 0;
}
```

## Comparación con JavaScript (Node.js)

El módulo `fs` de Node.js proporciona funcionalidades análogas.

- **Lectura/Escritura de Archivos Completos**: Para archivos pequeños, es común leer o escribir todo el contenido de una vez.
  ```javascript
  const fs = require("fs");
  // Escribir
  fs.writeFileSync("salida.txt", "Hola\nAdiós");
  // Leer
  const contenido = fs.readFileSync("salida.txt", "utf8");
  console.log(contenido);
  ```
- **Streams**: Para archivos grandes, Node.js utiliza un concepto de _Streams_ que es muy similar al de C. Permite procesar el archivo en trozos (`chunks`) sin cargarlo todo en memoria.
  ```javascript
  const fs = require("fs");
  const readerStream = fs.createReadStream("archivo_grande.txt");
  readerStream.on("data", (chunk) => {
    // Procesar cada trozo de datos
  });
  ```
- **E/S con Formato**: No hay un equivalente directo de `fprintf`/`fscanf`. En JS, se trabaja con formatos de datos estructurados como JSON. Se convierte el objeto a una cadena JSON para escribirlo, y se parsea la cadena JSON para leerlo.

  ```javascript
  const datos = { producto: "Tornillos", cantidad: 100, precio: 0.05 };
  fs.writeFileSync("inventario.json", JSON.stringify(datos));

  const datosLeidos = JSON.parse(fs.readFileSync("inventario.json", "utf8"));
  ```

## Resumen

- C ofrece un conjunto de funciones de E/S para diferentes necesidades:
  - **`fgetc`/`fputc`**: Para caracteres individuales.
  - **`fgets`/`fputs`**: Para líneas de texto.
  - **`fscanf`/`fprintf`**: Para datos con formato.
- La elección de la función correcta depende de la estructura de los datos en el archivo.
- Node.js ofrece abstracciones de más alto nivel (`readFileSync`) y un sistema de _Streams_ para archivos grandes, utilizando formatos como JSON para datos estructurados en lugar de `fscanf`/`fprintf`.

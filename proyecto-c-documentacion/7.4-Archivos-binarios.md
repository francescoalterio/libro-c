# 7.4. E/S de Bloques: `fread()` y `fwrite()`

Mientras que funciones como `fprintf` y `fscanf` son ideales para texto con formato, `fread()` y `fwrite()` están diseñadas para leer y escribir bloques de datos de tamaño fijo, típicamente en archivos binarios. Estas funciones no realizan ninguna conversión de datos; simplemente copian bytes directamente entre la memoria y el archivo.

Esto las hace extremadamente eficientes para guardar y recuperar datos complejos como arreglos, estructuras o cualquier bloque de memoria contiguo.

## Funciones Principales

- `size_t fwrite(const void *ptr, size_t tamano, size_t nmiemb, FILE *flujo);`

  - **`ptr`**: Apuntador al bloque de memoria que se va a escribir.
  - **`tamano`**: Tamaño en bytes de cada elemento a escribir.
  - **`nmiemb`**: Número de elementos a escribir.
  - **`flujo`**: El flujo del archivo.
  - **Valor de retorno**: Devuelve el número de elementos escritos con éxito. Si es menor que `nmiemb`, ocurrió un error.

- `size_t fread(void *ptr, size_t tamano, size_t nmiemb, FILE *flujo);`
  - **`ptr`**: Apuntador al bloque de memoria donde se almacenarán los datos leídos.
  - **`tamano`**: Tamaño en bytes de cada elemento a leer.
  - **`nmiemb`**: Número de elementos a leer.
  - **`flujo`**: El flujo del archivo.
  - **Valor de retorno**: Devuelve el número de elementos leídos con éxito. Si es menor que `nmiemb`, se alcanzó el final del archivo o ocurrió un error.

## Ejemplo: Guardar y Leer una Estructura en un Archivo Binario

Los archivos binarios son perfectos para almacenar estructuras, ya que `fwrite` puede volcar la representación en memoria de la estructura directamente al archivo.

```c
#include <stdio.h>
#include <stdlib.h>

// Definimos una estructura para nuestro ejemplo
struct Empleado {
    int id;
    char nombre[100];
    float salario;
};

int main() {
    FILE *archivo;
    struct Empleado emp_escritura = {101, "Juan Perez", 2500.50};
    struct Empleado emp_lectura;

    // --- ESCRITURA ---
    // Abrimos el archivo en modo de escritura binaria ("wb")
    archivo = fopen("empleados.dat", "wb");
    if (archivo == NULL) {
        perror("Error al abrir el archivo para escribir");
        return 1;
    }

    // Escribimos la estructura completa en el archivo
    // 1 elemento de tamaño sizeof(struct Empleado)
    size_t escritos = fwrite(&emp_escritura, sizeof(struct Empleado), 1, archivo);
    if (escritos < 1) {
        fprintf(stderr, "Error al escribir en el archivo.\n");
    } else {
        printf("Estructura de empleado guardada en 'empleados.dat'\n");
    }
    fclose(archivo);


    // --- LECTURA ---
    // Abrimos el archivo en modo de lectura binaria ("rb")
    archivo = fopen("empleados.dat", "rb");
    if (archivo == NULL) {
        perror("Error al abrir el archivo para leer");
        return 1;
    }

    // Leemos la estructura desde el archivo
    size_t leidos = fread(&emp_lectura, sizeof(struct Empleado), 1, archivo);
    if (leidos < 1) {
        fprintf(stderr, "Error al leer del archivo.\n");
    } else {
        printf("\nDatos del empleado leídos del archivo:\n");
        printf("ID: %d\n", emp_lectura.id);
        printf("Nombre: %s\n", emp_lectura.nombre);
        printf("Salario: %.2f\n", emp_lectura.salario);
    }
    fclose(archivo);

    return 0;
}
```

## Comparación con JavaScript (Node.js)

El manejo de datos binarios en Node.js se realiza principalmente con el objeto `Buffer`. Un `Buffer` es una región de memoria de tamaño fijo, similar a un arreglo de bytes en C.

No existe un análogo directo de `fread`/`fwrite` que mapee estructuras de JS a binario. El enfoque idiomático es:

1.  **Serializar**: Convertir los datos (ej. un objeto JavaScript) a un formato binario estandarizado como **Protocol Buffers (Protobuf)** o a un formato de texto como **JSON**.
2.  **Escribir**: Escribir el `Buffer` o la cadena resultante en un archivo.
3.  **Leer**: Leer el archivo en un `Buffer` o cadena.
4.  **Deserializar**: Convertir el `Buffer` o la cadena de vuelta a un objeto JavaScript.

**Ejemplo (usando JSON, que es texto, no binario puro):**

```javascript
const fs = require("fs");

const empleado = {
  id: 101,
  nombre: "Juan Perez",
  salario: 2500.5,
};

// 1. Serializar a JSON y 2. Escribir
fs.writeFileSync("empleado.json", JSON.stringify(empleado));
console.log("Datos del empleado guardados en empleado.json");

// 3. Leer y 4. Deserializar
const datosLeidos = fs.readFileSync("empleado.json", "utf8");
const empleadoLeido = JSON.parse(datosLeidos);

console.log("\nDatos leídos del archivo:");
console.log(empleadoLeido);
```

Para un verdadero manejo binario, se usarían bibliotecas como `protobuf.js` para convertir el objeto a un `Buffer` y viceversa.

## Ventajas y Desventajas de la E/S de Bloques

- **Ventajas**:
  - **Eficiencia**: Extremadamente rápido, ya que es una copia de memoria directa.
  - **Conveniencia**: Muy fácil para guardar y cargar estructuras de datos complejas.
- **Desventajas**:
  - **Portabilidad**: Los archivos binarios pueden no ser portables entre sistemas con diferente _endianness_ (orden de bytes) o tamaños de tipos de datos.
  - **Fragilidad**: Si la definición de la `struct` cambia (ej. se añade un campo), los archivos antiguos ya no se podrán leer correctamente.
  - **No legibles por humanos**: Dificulta la depuración y la interoperabilidad con otros sistemas.

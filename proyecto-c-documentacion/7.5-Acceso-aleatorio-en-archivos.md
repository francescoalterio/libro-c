# 7.5. Acceso Aleatorio en Archivos: `fseek`, `ftell` y `rewind`

Hasta ahora, hemos leído y escrito archivos de forma secuencial, desde el principio hasta el final. Sin embargo, C también permite el **acceso aleatorio**, que es la capacidad de mover el "cursor" o "puntero de posición" a cualquier parte del archivo para leer o escribir en esa ubicación específica. Esto es fundamental para aplicaciones que necesitan acceder a registros en un archivo de datos sin procesar todo el archivo.

## El Puntero de Posición del Archivo

Cada flujo de archivo (`FILE *`) mantiene un indicador de posición que determina dónde ocurrirá la próxima operación de lectura o escritura. Las funciones de acceso aleatorio manipulan este indicador.

### `fseek()`: Mover el puntero de posición

Esta es la función principal para el acceso aleatorio. Permite mover el puntero de posición a una ubicación específica dentro del archivo.

`int fseek(FILE *flujo, long int desplazamiento, int origen);`

- **`flujo`**: El flujo del archivo sobre el que se operará.
- **`desplazamiento`**: El número de bytes que se moverá el puntero. Puede ser positivo (hacia adelante) o negativo (hacia atrás).
- **`origen`**: Define el punto de partida para el `desplazamiento`. Es una de tres constantes:
  - `SEEK_SET`: Mueve el puntero a `desplazamiento` bytes desde el **inicio** del archivo.
  - `SEEK_CUR`: Mueve el puntero a `desplazamiento` bytes desde la **posición actual**.
  - `SEEK_END`: Mueve el puntero a `desplazamiento` bytes desde el **final** del archivo (normalmente se usa un desplazamiento negativo o cero).

### `ftell()`: Obtener la posición actual

Esta función devuelve la posición actual del puntero del archivo, medida en bytes desde el inicio.

`long int ftell(FILE *flujo);`

Es útil para saber dónde te encuentras, para volver a esa posición más tarde o para calcular el tamaño de un archivo moviéndose al final y llamando a `ftell`.

### `rewind()`: Volver al inicio

Es una función de conveniencia que restablece el puntero de posición al principio del archivo.

`void rewind(FILE *flujo);`

Es equivalente a `fseek(flujo, 0L, SEEK_SET)`, pero también borra los indicadores de error del flujo.

## Ejemplo: Acceder a un Registro Específico

Imaginemos un archivo binario `records.dat` que contiene una secuencia de estructuras. Podemos usar `fseek` para saltar directamente al registro N-ésimo.

```c
#include <stdio.h>

typedef struct {
    int id;
    char name[50];
} Record;

int main() {
    FILE *file;
    Record rec;
    long size_of_record = sizeof(Record);

    // Crear un archivo de ejemplo con 3 registros
    file = fopen("records.dat", "wb");
    for (int i = 0; i < 3; ++i) {
        rec.id = i + 1;
        sprintf(rec.name, "Record %d", i + 1);
        fwrite(&rec, size_of_record, 1, file);
    }
    fclose(file);

    // Ahora, abrir para leer y acceder al segundo registro (índice 1)
    file = fopen("records.dat", "rb");
    if (file == NULL) {
        perror("Error al abrir archivo");
        return 1;
    }

    // Queremos el segundo registro, por lo que nos movemos
    // la distancia de 1 registro desde el inicio.
    int record_index = 1;
    if (fseek(file, record_index * size_of_record, SEEK_SET) != 0) {
        fprintf(stderr, "Error al buscar en el archivo\n");
        fclose(file);
        return 1;
    }

    // Leer el registro en la posición actual
    if (fread(&rec, size_of_record, 1, file) == 1) {
        printf("Se ha leído el registro en el índice %d:\n", record_index);
        printf("ID: %d, Nombre: %s\n", rec.id, rec.name);
    }

    // Usar ftell para ver la posición actual
    long current_pos = ftell(file);
    printf("El puntero está ahora en la posición: %ld\n", current_pos);

    // Volver al inicio con rewind
    rewind(file);
    current_pos = ftell(file);
    printf("Después de rewind, la posición es: %ld\n", current_pos);

    fclose(file);
    return 0;
}
```

## Comparación con JavaScript (Node.js)

En Node.js, no se manipula un "puntero de archivo" directamente. En su lugar, las funciones de lectura y escritura de bajo nivel, como `fs.read()` y `fs.write()`, aceptan un parámetro de `position` que especifica dónde comenzar la operación dentro del archivo.

```javascript
const fs = require("fs");

// Para leer desde una posición específica, se necesita un descriptor de archivo
fs.open("some.file", "r", (err, fd) => {
  if (err) throw err;

  const buffer = Buffer.alloc(100); // Búfer para almacenar los datos
  const position_to_read_from = 50; // Byte de inicio
  const bytes_to_read = 10;

  // fs.read(fd, buffer, offset, length, position, callback)
  // - offset: dónde empezar a escribir en el buffer
  // - length: cuántos bytes leer
  // - position: desde dónde leer en el archivo
  fs.read(
    fd,
    buffer,
    0,
    bytes_to_read,
    position_to_read_from,
    (err, bytesRead, buf) => {
      if (err) throw err;
      console.log(`Se leyeron ${bytesRead} bytes.`);
      console.log(buf.toString("utf8", 0, bytesRead));
      fs.close(fd, () => {});
    }
  );
});
```

El enfoque de Node.js es más abstracto, especificando el destino en cada llamada, mientras que C mantiene un estado (la posición del puntero) que se modifica explícitamente.

## Resumen

- El acceso aleatorio es crucial para manipular eficientemente archivos grandes o estructurados.
- `fseek` es la herramienta principal para mover el puntero de posición del archivo.
- `ftell` informa sobre la posición actual.
- `rewind` es un atajo para volver al inicio.
- Este mecanismo es fundamental para implementar sistemas de bases de datos simples, índices de archivos o cualquier aplicación que requiera acceso no secuencial a los datos.

# 7.6. Manejo de Errores en Archivos

Las operaciones con archivos son propensas a errores: un archivo puede no existir, los permisos pueden ser insuficientes, el disco puede estar lleno, etc. Un programa robusto debe anticipar y manejar estos errores de manera adecuada. C proporciona varios mecanismos para detectar y reportar errores de E/S.

## Detección de Errores

Existen dos formas principales de saber si una operación de archivo ha fallado:

1.  **Valores de Retorno**: La mayoría de las funciones de E/S devuelven un valor especial para indicar un error.

    - `fopen()`: Devuelve `NULL` si no puede abrir el archivo.
    - `fgetc()`, `fputc()`: Devuelven `EOF`.
    - `fread()`, `fwrite()`: Devuelven un número de elementos leídos/escritos menor al solicitado.
    - `fseek()`: Devuelve un valor distinto de cero.

2.  **Indicadores de Error y Fin de Archivo**: A veces, un valor de retorno como `EOF` es ambiguo. ¿Se alcanzó el final del archivo o ocurrió un error de lectura? Para distinguirlo, C ofrece dos funciones:
    - `int feof(FILE *flujo)`: Devuelve un valor distinto de cero (verdadero) si el indicador de **fin de archivo** está activado para el flujo.
    - `int ferror(FILE *flujo)`: Devuelve un valor distinto de cero (verdadero) si el indicador de **error** está activado para el flujo.

### `clearerr()`

- `void clearerr(FILE *flujo)`: Esta función restablece (pone a cero) los indicadores de error y fin de archivo para un flujo. Es útil si quieres intentar una operación de nuevo después de un error no fatal.

## Reporte de Errores

Una vez que se detecta un error, es útil informar al usuario _qué_ salió mal.

- `void perror(const char *s)`: Es la forma más común y recomendada. Imprime la cadena `s` que le pasas, seguida de dos puntos, un espacio y un mensaje de error descriptivo correspondiente al valor actual de la variable global `errno`.
- `char *strerror(int errnum)`: Devuelve un puntero a una cadena que describe el código de error `errnum`. Te da más control sobre cómo formatear el mensaje.

## Ejemplo Práctico de Manejo de Errores

```c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>  // Necesario para errno
#include <string.h> // Necesario para strerror

int main() {
    FILE *file;

    // --- Error al Abrir ---
    file = fopen("archivo_inexistente.txt", "r");
    if (file == NULL) {
        // perror es la forma más sencilla
        perror("Error al intentar abrir el archivo");

        // Forma alternativa usando strerror
        fprintf(stderr, "Error detallado: %s\n", strerror(errno));
        // Salimos porque no podemos continuar
        return 1;
    }

    // --- Error durante la Lectura ---
    // Forzamos un error intentando leer de un archivo abierto en modo escritura
    file = fopen("salida.txt", "w");
    if (file == NULL) {
        perror("Error abriendo en modo escritura");
        return 1;
    }
    fputc('A', file); // Escribimos algo

    // Intentar leer de un archivo de solo escritura causará un error
    fgetc(file);

    if (ferror(file)) {
        printf("\nSe ha detectado un error durante una operación de archivo.\n");
        perror("Detalle del error de E/S");
        clearerr(file); // Limpiamos el indicador de error
    }

    // --- Distinguir EOF de Error ---
    // Supongamos que leemos un archivo hasta el final
    // while ((c = fgetc(file)) != EOF) { /* ... */ }
    // Después del bucle, comprobamos por qué terminó:
    if (feof(file)) {
        printf("Se alcanzó el final del archivo.\n");
    } else if (ferror(file)) {
        printf("Terminó debido a un error de lectura.\n");
    }

    fclose(file);
    return 0;
}
```

## Comparación con JavaScript (Node.js)

El manejo de errores en C y JavaScript es filosóficamente diferente.

- **C (Basado en estado y valores de retorno)**:

  - El programador es responsable de verificar explícitamente los valores de retorno o los indicadores de error (`ferror`, `feof`) después de cada operación.
  - La variable global `errno` almacena el código del último error.
  - Es un modelo proactivo: _pregunta_ si algo salió mal.

- **JavaScript (Basado en excepciones y callbacks/promesas)**:
  - **Sincrónico**: Se usa el bloque `try...catch`. Si `fs.readFileSync()` falla, lanza una excepción que es capturada por el bloque `catch`.
    ```javascript
    try {
      const data = fs.readFileSync("archivo_inexistente.txt");
    } catch (err) {
      console.error("Ocurrió un error:", err.message);
    }
    ```
  - **Asincrónico (Callbacks)**: El error se pasa como el primer argumento a la función de callback.
    ```javascript
    fs.readFile("archivo.txt", (err, data) => {
      if (err) {
        console.error("Error:", err.message);
        return;
      }
      // Procesar data
    });
    ```
  - **Asincrónico (Promesas)**: Los errores se manejan en el bloque `.catch()`.
    ```javascript
    fs.promises
      .readFile("archivo.txt")
      .then((data) => {
        /* ... */
      })
      .catch((err) => console.error("Error:", err.message));
    ```
  - Es un modelo reactivo: el sistema te _notifica_ (lanza una excepción, llama a un callback de error) cuando algo sale mal.

## Resumen

- El manejo de errores en C es un proceso manual pero detallado.
- **Siempre** comprueba el valor de retorno de `fopen()`.
- Usa `ferror()` y `feof()` para determinar el estado de un flujo después de una operación de lectura/escritura.
- Usa `perror()` para obtener mensajes de error claros y estandarizados.
- Este enfoque contrasta con el manejo de excepciones de lenguajes modernos como JavaScript, que centraliza la lógica de errores en bloques `catch`.

# 7.7. Ejemplo Integrador: Mini-Sistema de Inventario

Este ejemplo práctico consolida todos los conceptos clave del capítulo sobre manejo de archivos en C. Crearemos un pequeño programa de línea de comandos para gestionar un inventario de productos. Los datos se almacenarán en un archivo binario.

El programa demostrará:

1.  **Estructuras**: Para definir el formato de nuestros registros de productos.
2.  **Apertura y Cierre**: Con el modo `"r+b"`, que permite leer y escribir en un archivo binario existente.
3.  **E/S de Bloques**: Usando `fread()` y `fwrite()` para leer y escribir estructuras completas.
4.  **Acceso Aleatorio**: Empleando `fseek()` para saltar a registros específicos para verlos o actualizarlos.
5.  **Manejo de Errores**: Verificando los valores de retorno y usando `perror()` en cada paso.

## El Programa: `inventario.c`

Este programa permitirá al usuario agregar nuevos productos, ver los detalles de un producto existente por su ID y actualizar el stock de un producto.

### El Código Completo

```c
#include <stdio.h>
#include <stdlib.h>

const char* FILENAME = "inventario.dat";

// 1. Estructura para nuestros datos
typedef struct {
    int id;
    char nombre[50];
    int cantidad;
    double precio;
} Producto;

void agregar_producto();
void ver_producto();
void actualizar_stock();

int main() {
    // Crear el archivo si no existe
    FILE *file = fopen(FILENAME, "ab");
    if (file == NULL) {
        perror("No se pudo crear el archivo inicial");
        return 1;
    }
    fclose(file);

    int opcion;
    do {
        printf("\n--- SISTEMA DE INVENTARIO ---\n");
        printf("1. Agregar un nuevo producto\n");
        printf("2. Ver un producto por ID\n");
        printf("3. Actualizar stock de un producto\n");
        printf("4. Salir\n");
        printf("Seleccione una opción: ");
        scanf("%d", &opcion);

        switch (opcion) {
            case 1:
                agregar_producto();
                break;
            case 2:
                ver_producto();
                break;
            case 3:
                actualizar_stock();
                break;
            case 4:
                printf("Saliendo del programa.\n");
                break;
            default:
                printf("Opción no válida.\n");
        }
    } while (opcion != 4);

    return 0;
}

// Agrega un producto al final del archivo
void agregar_producto() {
    FILE *file = fopen(FILENAME, "ab"); // Append Binary
    if (file == NULL) {
        perror("Error al abrir el archivo para agregar");
        return;
    }

    Producto p;
    printf("Ingrese ID del producto: ");
    scanf("%d", &p.id);
    printf("Ingrese nombre: ");
    scanf(" %[^\n]", p.nombre); // Lee hasta el salto de línea
    printf("Ingrese cantidad: ");
    scanf("%d", &p.cantidad);
    printf("Ingrese precio: ");
    scanf("%lf", &p.precio);

    fwrite(&p, sizeof(Producto), 1, file);
    printf("Producto agregado con éxito.\n");
    fclose(file);
}

// Usa acceso aleatorio para leer un producto por su ID
void ver_producto() {
    FILE *file = fopen(FILENAME, "rb"); // Read Binary
    if (file == NULL) {
        perror("Error al abrir el archivo para ver");
        return;
    }

    int id_buscar;
    printf("Ingrese el ID del producto a ver: ");
    scanf("%d", &id_buscar);

    Producto p;
    int encontrado = 0;
    // Leemos secuencialmente hasta encontrar el ID
    while (fread(&p, sizeof(Producto), 1, file) == 1) {
        if (p.id == id_buscar) {
            printf("\n--- Detalles del Producto ---\n");
            printf("ID:       %d\n", p.id);
            printf("Nombre:   %s\n", p.nombre);
            printf("Cantidad: %d\n", p.cantidad);
            printf("Precio:   %.2f\n", p.precio);
            encontrado = 1;
            break;
        }
    }

    if (!encontrado) {
        printf("Producto con ID %d no encontrado.\n", id_buscar);
    }
    fclose(file);
}

// Usa acceso aleatorio para encontrar, leer y sobreescribir un producto
void actualizar_stock() {
    // r+b: Leer y escribir en archivo binario. El archivo DEBE existir.
    FILE *file = fopen(FILENAME, "r+b");
    if (file == NULL) {
        perror("Error al abrir el archivo para actualizar");
        return;
    }

    int id_buscar;
    printf("Ingrese el ID del producto a actualizar: ");
    scanf("%d", &id_buscar);

    Producto p;
    long pos = -1; // Posición en el archivo

    // Buscamos la posición del registro
    while (fread(&p, sizeof(Producto), 1, file) == 1) {
        if (p.id == id_buscar) {
            pos = ftell(file) - sizeof(Producto);
            break;
        }
    }

    if (pos != -1) {
        printf("Stock actual de '%s': %d. Ingrese nuevo stock: ", p.nombre, p.cantidad);
        scanf("%d", &p.cantidad);

        // 4. Movemos el puntero a la posición correcta
        fseek(file, pos, SEEK_SET);
        // 5. Sobreescribimos el registro
        fwrite(&p, sizeof(Producto), 1, file);
        printf("Stock actualizado con éxito.\n");
    } else {
        printf("Producto con ID %d no encontrado.\n", id_buscar);
    }

    fclose(file);
}
```

### Análisis del Código

- **Modos de Archivo**:
  - `"ab"` (Append Binary): Se usa para agregar un nuevo producto. Coloca el puntero al final del archivo automáticamente.
  - `"rb"` (Read Binary): Se usa para leer y buscar productos sin riesgo de modificar el archivo.
  - `"r+b"` (Read/Update Binary): Es el modo más potente. Permite leer y escribir. Es crucial para la función de actualización, ya que necesitamos encontrar el registro (`read`), mover el puntero hacia atrás (`fseek`) y luego sobreescribirlo (`write`).
- **Acceso Aleatorio en `actualizar_stock()`**:
  1.  Se abre el archivo en modo `"r+b"`.
  2.  Se lee secuencialmente para encontrar el producto.
  3.  Cuando se encuentra, `ftell(file)` nos da la posición _después_ del registro leído. Restamos `sizeof(Producto)` para obtener la posición de _inicio_ de ese registro.
  4.  Después de obtener la nueva cantidad del usuario, usamos `fseek(file, pos, SEEK_SET)` para mover el puntero de vuelta al inicio del registro que queremos modificar.
  5.  `fwrite()` sobreescribe los bytes exactos del registro antiguo con los del nuevo.

## Comparación con JavaScript (Node.js)

Realizar este tipo de manipulación de bajo nivel en un archivo binario es poco común en el ecosistema de Node.js. El enfoque idiomático sería muy diferente:

1.  **Usar una Base de Datos**: Para una tarea como esta, la solución más robusta y estándar sería usar una base de datos ligera como **SQLite**. La biblioteca `sqlite3` en Node.js permitiría ejecutar consultas SQL (`INSERT`, `SELECT`, `UPDATE`) que son mucho más expresivas y seguras que la manipulación manual de bytes.

2.  **Archivo JSON como "Base de Datos"**: Para una solución simple sin dependencias externas, un desarrollador de Node.js probablemente haría lo siguiente:
    - Leer el archivo `inventario.json` completo en la memoria usando `fs.readFileSync()`.
    - Convertir la cadena JSON en un arreglo de objetos JavaScript con `JSON.parse()`.
    - Realizar todas las operaciones (agregar, buscar, modificar) en el arreglo en memoria.
    - Escribir el arreglo modificado de vuelta al archivo `inventario.json` usando `JSON.stringify()` y `fs.writeFileSync()`.

Este enfoque es más simple pero menos eficiente para archivos muy grandes, ya que todo el archivo debe cargarse en la memoria. El enfoque de C es mucho más eficiente en memoria, ya que solo carga un registro a la vez.

## Conclusión

Este ejemplo demuestra el poder y el control que C ofrece sobre la E/S de archivos. Al combinar estructuras, E/S de bloques y acceso aleatorio, podemos construir sistemas de almacenamiento de datos personalizados y eficientes directamente desde cero, una tarea que en otros lenguajes a menudo se abstrae detrás de bibliotecas de bases de datos o serializadores de objetos.

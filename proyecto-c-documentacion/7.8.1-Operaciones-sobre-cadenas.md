# 7.8.1. Operaciones sobre Cadenas (`<string.h>`)

En C, una "cadena" no es un tipo de dato nativo, sino una convención: es un **arreglo de caracteres (`char`) que termina con un carácter nulo (`\0`)**. Esta convención es simple pero poderosa, y la biblioteca `<string.h>` proporciona un conjunto de funciones estandarizadas para manipular estas cadenas de manera segura y eficiente.

Es crucial recordar que, al trabajar con estas funciones, el programador es responsable de asegurar que los arreglos de destino tengan suficiente espacio para el resultado, incluyendo el carácter nulo final. Un fallo en esto puede llevar a **desbordamientos de búfer (buffer overflows)**, una de las vulnerabilidades de seguridad más comunes.

## Funciones Principales de `<string.h>`

### Copia y Concatenación

- `char *strcpy(char *destino, const char *origen);`
  Copia la cadena `origen` (incluyendo el `\0`) en `destino`. **Peligroso**: no comprueba el tamaño de `destino`.
- `char *strncpy(char *destino, const char *origen, size_t n);`
  Versión segura de `strcpy`. Copia como máximo `n` caracteres. Si `origen` es más corto que `n`, rellena con `\0`. Si es más largo, **no añade el `\0` automáticamente**, por lo que el programador debe hacerlo.
- `char *strcat(char *destino, const char *origen);`
  Añade (concatena) la cadena `origen` al final de `destino`. El primer carácter de `origen` sobreescribe el `\0` de `destino`. **Peligroso**: no comprueba el tamaño.
- `char *strncat(char *destino, const char *origen, size_t n);`
  Versión segura de `strcat`. Añade como máximo `n` caracteres de `origen` y siempre añade un `\0` al final.

**Ejemplo de Copia y Concatenación Segura:**

```c
#include <stdio.h>
#include <string.h>

int main() {
    char saludo[20] = "Hola"; // Búfer con espacio de sobra
    char nombre[] = "Mundo";

    // Usamos strncat para concatenar de forma segura
    // sizeof(saludo) - strlen(saludo) - 1 es el espacio restante
    strncat(saludo, ", ", sizeof(saludo) - strlen(saludo) - 1);
    strncat(saludo, nombre, sizeof(saludo) - strlen(saludo) - 1);

    printf("Resultado: %s\n", saludo); // Resultado: Hola, Mundo

    char destino[10];
    char fuente[] = "Esto es muy largo";
    strncpy(destino, fuente, sizeof(destino) - 1);
    destino[sizeof(destino) - 1] = '\0'; // Aseguramos el nulo final
    printf("Destino truncado: %s\n", destino); // Destino truncado: Esto es m
    return 0;
}
```

### Comparación

- `int strcmp(const char *s1, const char *s2);`
  Compara `s1` y `s2` lexicográficamente. Devuelve:
  - `< 0` si `s1` es menor que `s2`.
  - `0` si `s1` es igual a `s2`.
  - `> 0` si `s1` es mayor que `s2`.
- `int strncmp(const char *s1, const char *s2, size_t n);`
  Compara como máximo los primeros `n` caracteres de `s1` y `s2`.

### Longitud y Búsqueda

- `size_t strlen(const char *s);`
  Devuelve el número de caracteres en `s`, **sin incluir** el carácter nulo `\0`.
- `char *strchr(const char *s, int c);`
  Busca la primera ocurrencia del carácter `c` en la cadena `s`. Devuelve un puntero a la primera ocurrencia o `NULL` si no se encuentra.
- `char *strstr(const char *haystack, const char *needle);`
  Busca la primera ocurrencia de la subcadena `needle` dentro de la cadena `haystack`. Devuelve un puntero al inicio de la subcadena encontrada o `NULL`.

**Ejemplo de Búsqueda:**

```c
#include <stdio.h>
#include <string.h>

int main() {
    const char *frase = "El rápido zorro marrón salta sobre el perro perezoso.";
    const char *palabra = "marrón";

    char *encontrado = strstr(frase, palabra);

    if (encontrado != NULL) {
        printf("La palabra '%s' fue encontrada en la posición: %ld\n", palabra, encontrado - frase);
    } else {
        printf("La palabra '%s' no fue encontrada.\n", palabra);
    }
    return 0;
}
```

## Comparación con JavaScript

El manejo de cadenas en C y JavaScript es fundamentalmente diferente.

| Característica   | C (`<string.h>`)                                                                             | JavaScript (`String`)                                                                                        |
| :--------------- | :------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------- |
| **Tipo de Dato** | Arreglo de `char` terminado en `\0`.                                                         | Objeto `String` primitivo e inmutable.                                                                       |
| **Mutabilidad**  | **Mutable**. Las cadenas pueden ser modificadas en su lugar (ej. `strcat`).                  | **Inmutable**. Cualquier operación que "modifica" una cadena en realidad devuelve una nueva.                 |
| **Operaciones**  | Funciones globales (`strcpy`, `strlen`, etc.) que operan sobre punteros.                     | Métodos del objeto (`.concat()`, `.slice()`, etc.) y propiedades (`.length`).                                |
| **Memoria**      | **Manual**. El programador debe asignar y gestionar la memoria. Riesgo de _buffer overflow_. | **Automática**. El motor de JS gestiona la memoria (recolección de basura). Sin riesgo de _buffer overflow_. |
| **Ejemplo**      | `char s[20]; strcpy(s, "hola"); strcat(s, " mundo");`                                        | `let s = "hola"; s = s + " mundo";`                                                                          |

## Buenas Prácticas y Seguridad

- **Prefiere las funciones `n`**: Siempre que sea posible, usa `strncpy`, `strncat`, y `strncmp` en lugar de sus contrapartes inseguras. Te obligan a pensar en los tamaños de los búferes.
- **Asegura el Nulo Final**: Cuando uses `strncpy`, recuerda que podría no terminar la cadena de destino con `\0`. Es una buena práctica hacerlo manualmente si existe la posibilidad de truncamiento.
- **Calcula el Espacio Correctamente**: Al concatenar, asegúrate de que el búfer de destino sea lo suficientemente grande para contener la cadena original, la cadena a añadir y el carácter nulo. `strlen(dest) + strlen(src) + 1`.

Dominar las funciones de `<string.h>` y sus implicaciones de seguridad es un paso esencial para escribir código en C robusto y seguro.

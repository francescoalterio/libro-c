# 7.8.3. La Función `ungetc`

La función `ungetc` es una herramienta especializada pero muy útil de la biblioteca `<stdio.h>`. Su propósito es "devolver" (push back) un carácter al flujo de entrada (`stream`). Esto significa que el carácter devuelto será el primero en ser leído en la siguiente operación de lectura de ese flujo.

Esta función es fundamental en la construcción de analizadores léxicos (lexers) y sintácticos (parsers), donde a menudo es necesario leer un carácter "de más" para decidir qué hacer, y luego "devolverlo" para que pueda ser procesado correctamente por otra parte del código.

## Firma y Funcionamiento

`int ungetc(int c, FILE *flujo);`

- **`c`**: El carácter que se va a devolver al flujo.
- **`flujo`**: El flujo de entrada (por ejemplo, `stdin` o un archivo abierto para lectura).
- **Valor de Retorno**: Si tiene éxito, `ungetc` devuelve el carácter `c` que fue devuelto. Si falla, devuelve `EOF`.

**Características Clave:**

- La biblioteca estándar garantiza que se puede devolver al menos **un** carácter. Intentar devolver más de un carácter sin una operación de lectura intermedia puede fallar.
- El carácter devuelto no tiene por qué ser el mismo que se acaba de leer, lo que permite sustituir caracteres en el flujo de entrada.
- Devolver `EOF` es una operación no válida y causará un error.

## Caso de Uso: Analizador Simple (Parser)

Imagina que estás leyendo datos de un archivo y necesitas leer un número entero. El número puede estar seguido por cualquier otro carácter (un espacio, una coma, una letra, etc.). El problema es que para saber que has terminado de leer el número, tienes que leer el primer carácter que _no_ es un dígito. Este carácter no numérico forma parte del siguiente "token" y debe ser procesado más tarde.

Aquí es donde `ungetc` brilla.

**Ejemplo: Leer un número y devolver el siguiente carácter**

```c
#include <stdio.h>
#include <ctype.h>

// Función para leer un número entero de stdin
int leer_numero() {
    int c, numero = 0;

    // Omitir cualquier espacio en blanco inicial
    while (isspace(c = getchar()));

    // Leer los dígitos y construir el número
    while (isdigit(c)) {
        numero = 10 * numero + (c - '0');
        c = getchar();
    }

    // Hemos leído un carácter que no es un dígito.
    // Lo devolvemos al flujo para que no se pierda.
    if (c != EOF) {
        ungetc(c, stdin);
    }

    return numero;
}

int main() {
    printf("Escribe un número seguido de texto (ej: 123abc): ");

    int numero = leer_numero();
    printf("Número leído: %d\n", numero);

    printf("El resto de la entrada es: ");
    int resto;
    while ((resto = getchar()) != '\n' && resto != EOF) {
        putchar(resto);
    }
    putchar('\n');

    return 0;
}
```

**Cómo funciona el ejemplo:**

1.  El usuario introduce `123abc`.
2.  `leer_numero` lee `'1'`, `'2'`, `'3'` y los usa para construir el entero `123`.
3.  La siguiente llamada a `getchar()` lee la `'a'`.
4.  `isdigit('a')` es falso, por lo que el bucle termina.
5.  La `'a'` es un carácter importante que no debe perderse. `ungetc('a', stdin)` la "devuelve" al búfer de entrada estándar.
6.  La función `leer_numero` retorna `123`.
7.  En `main`, el bucle `while` para leer el resto de la entrada comienza. La primera llamada a `getchar()` lee la `'a'` que fue devuelta, y luego continúa con `b`, `c`, etc.

## Comparación con JavaScript

JavaScript no tiene un concepto directo de `ungetc` porque no suele trabajar con flujos de entrada de bajo nivel de la misma manera que C. Los problemas que `ungetc` resuelve en C se abordan de manera diferente en JS, generalmente operando sobre cadenas completas.

**Enfoque en JavaScript:**

En lugar de leer carácter por carácter, se suele tener la cadena completa o se utiliza un índice para mantener la posición actual. "Echar un vistazo" (peek) al siguiente carácter es tan simple como mirar `str[index + 1]`. "Devolver" un carácter es simplemente no avanzar el índice.

```javascript
function leerNumero(str, startIndex) {
  let numeroStr = "";
  let i = startIndex;

  // Omitir espacios en blanco
  while (i < str.length && /\s/.test(str[i])) {
    i++;
  }

  // Leer dígitos
  while (i < str.length && /\d/.test(str[i])) {
    numeroStr += str[i];
    i++;
  }

  // No necesitamos "ungetc". El nuevo índice 'i' es la posición
  // del primer carácter no numérico.
  return {
    numero: parseInt(numeroStr, 10),
    nuevoIndice: i,
  };
}

const entrada = "123abc";
const resultado = leerNumero(entrada, 0);

console.log(`Número leído: ${resultado.numero}`); // 123
console.log(
  `El resto de la entrada es: ${entrada.substring(resultado.nuevoIndice)}`
); // abc
```

El enfoque de JS es de más alto nivel. En lugar de manipular el flujo de entrada, se manipula un índice que apunta a la cadena de entrada.

## Resumen

- `ungetc` es una función de bajo nivel para devolver un carácter a un flujo de entrada.
- Es una herramienta indispensable para escribir analizadores (parsers) en C, ya que permite implementar la lógica de "mirar hacia adelante" (lookahead) de un carácter.
- Representa una diferencia de paradigma fundamental con lenguajes como JavaScript, que operan con abstracciones de más alto nivel como cadenas completas e índices.

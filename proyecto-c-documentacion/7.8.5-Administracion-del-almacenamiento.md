# 7.8.5. Gestión de Memoria Dinámica (`<stdlib.h>`)

En C, existen dos lugares principales donde se almacena la memoria: la **pila (stack)** y el **montón (heap)**.

- **La Pila (Stack)**: Es donde se almacenan las variables locales de las funciones. Es gestionada automáticamente por el compilador. La memoria se "asigna" cuando se entra a una función y se "libera" cuando se sale. Es muy rápida, pero su tamaño es limitado y se conoce en tiempo de compilación.
  ```c
  void mi_funcion() {
      int x; // x se almacena en la pila
      char buffer[100]; // buffer se almacena en la pila
  }
  ```
- **El Montón (Heap)**: Es una gran región de memoria disponible para el programa en tiempo de ejecución. A diferencia de la pila, su tamaño no es fijo y puede ser utilizado para almacenar datos cuyo tamaño no se conoce en tiempo de compilación o que deben persistir más allá de la vida de una función. Esta memoria debe ser gestionada **manualmente** por el programador.

Las funciones de gestión de memoria dinámica de `<stdlib.h>` operan sobre el montón.

## Las Funciones de Gestión de Memoria

### `malloc`: Asignar Memoria

`void* malloc(size_t size);`

- Asigna un bloque de memoria de `size` bytes.
- **No inicializa** la memoria. Su contenido es basura (indeterminado).
- Devuelve un puntero de tipo `void*` a la primera dirección del bloque asignado. Este puntero debe ser "casteado" al tipo de dato deseado.
- Si no hay suficiente memoria disponible, devuelve `NULL`. **Siempre debes comprobar si el resultado es `NULL`**.

### `calloc`: Asignar y Limpiar Memoria

`void* calloc(size_t num_elements, size_t element_size);`

- Asigna memoria para un arreglo de `num_elements`, cada uno de `element_size` bytes.
- **Inicializa** todos los bytes del bloque de memoria a cero.
- Es ligeramente más lenta que `malloc` debido a la inicialización, pero más segura.
- También devuelve `NULL` si falla.

### `realloc`: Reajustar el Tamaño de la Memoria

`void* realloc(void* ptr, size_t new_size);`

- Cambia el tamaño del bloque de memoria apuntado por `ptr` a `new_size`.
- Si `new_size` es mayor, la memoria adicional no se inicializa.
- Si `new_size` es menor, los datos se truncan.
- Puede que mueva el bloque de memoria a una nueva ubicación si no hay espacio para expandirlo en su lugar actual. Por eso, siempre debes reasignar el puntero: `ptr = realloc(ptr, new_size);`.
- Si falla, devuelve `NULL` y el bloque de memoria original (`ptr`) permanece sin cambios.

### `free`: Liberar Memoria

`void free(void* ptr);`

- Libera el bloque de memoria apuntado por `ptr` (que debe haber sido asignado por `malloc`, `calloc` o `realloc`), devolviéndolo al montón para que pueda ser reutilizado.
- Usar la memoria después de `free` (puntero colgante) o liberar el mismo puntero dos veces (doble liberación) son errores graves.

## Ejemplo: Crear un Arreglo Dinámico

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n;
    printf("¿Cuántos números quieres almacenar? ");
    scanf("%d", &n);

    // 1. Asignar memoria para 'n' enteros usando malloc
    // Usamos sizeof para portabilidad
    int *arr = (int*) malloc(n * sizeof(int));

    // 2. Comprobar si la asignación falló
    if (arr == NULL) {
        fprintf(stderr, "Error: No se pudo asignar memoria.\n");
        return 1; // Salir con código de error
    }

    printf("Memoria asignada. Por favor, introduce %d números:\n", n);
    for (int i = 0; i < n; i++) {
        arr[i] = i * 10; // Llenamos el arreglo con datos
    }

    printf("Los números son: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // 3. Liberar la memoria cuando ya no se necesita
    free(arr);
    arr = NULL; // Buena práctica: poner el puntero a NULL tras liberarlo

    return 0;
}
```

## Errores Comunes (¡Cuidado!)

1.  **Fuga de Memoria (Memory Leak)**: Olvidar llamar a `free` para la memoria asignada. El programa "pierde" esa memoria y no puede reutilizarla. En programas de larga duración, esto puede agotar toda la memoria disponible.
2.  **Puntero Colgante (Dangling Pointer)**: Intentar usar un puntero después de que la memoria a la que apuntaba ha sido liberada con `free`. El comportamiento es indefinido y suele causar que el programa se caiga.
3.  **Doble Liberación (Double Free)**: Llamar a `free` dos veces sobre el mismo puntero. Esto corrompe la estructura interna del montón y puede causar un fallo inmediato o posterior.

## Comparación con JavaScript

Aquí la diferencia es total. JavaScript es un lenguaje con **gestión automática de memoria** a través de un proceso llamado **recolector de basura (Garbage Collector, GC)**.

| Característica       | C                                                                                             | JavaScript                                                                                                                                                                            |
| :------------------- | :-------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Asignación**       | **Manual**: `malloc`, `calloc`.                                                               | **Automática**: Al crear un objeto, arreglo, etc. (`let obj = {}`, `let arr = []`).                                                                                                   |
| **Liberación**       | **Manual**: `free`. El programador es 100% responsable.                                       | **Automática**: El recolector de basura se ejecuta periódicamente.                                                                                                                    |
| **Mecanismo del GC** | No aplica.                                                                                    | El GC busca objetos que ya no son "alcanzables" desde el código principal (por ejemplo, no hay ninguna variable que apunte a ellos) y libera la memoria que ocupan.                   |
| **Control**          | **Total**. Permite optimizaciones de bajo nivel y control preciso sobre el uso de la memoria. | **Ninguno (o muy poco)**. El programador no controla cuándo se ejecuta el GC.                                                                                                         |
| **Errores**          | Fugas de memoria, punteros colgantes, doble liberación.                                       | **Fugas de memoria conceptuales**: Es posible crear fugas si se mantienen referencias a objetos innecesarios (ej. en closures o variables globales), impidiendo que el GC los limpie. |

**Ejemplo en JavaScript:**

```javascript
function crearArreglo(n) {
  let arr = []; // La memoria se asigna automáticamente
  for (let i = 0; i < n; i++) {
    arr.push(i * 10);
  }
  return arr;
} // Cuando la función termina, si no hay más referencias a 'arr',
// el recolector de basura eventualmente la eliminará.

let miArreglo = crearArreglo(5);
// ... usar miArreglo ...
miArreglo = null; // Al eliminar la última referencia, el objeto es elegible para recolección.
```

## Resumen

- La gestión manual de memoria en C es una de sus características más potentes y peligrosas.
- Otorga un control sin precedentes sobre el rendimiento, pero exige una gran disciplina del programador.
- El ciclo `malloc` -> `comprobar NULL` -> `usar` -> `free` es fundamental.
- Este modelo contrasta radicalmente con el de lenguajes como JavaScript, que priorizan la seguridad y la facilidad de uso a costa del control de bajo nivel, automatizando la gestión de memoria.

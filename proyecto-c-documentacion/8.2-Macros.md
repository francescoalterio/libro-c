# 8.2. Macros con `#define`

La directiva `#define` es una de las herramientas más potentes y, a la vez, más delicadas del preprocesador de C. Permite crear **macros**, que son esencialmente reglas de sustitución de texto. El preprocesador escanea el código fuente y, cada vez que encuentra el identificador de una macro, lo reemplaza por el "cuerpo" de la macro antes de que el compilador vea el código.

Existen dos tipos principales de macros: macros tipo objeto y macros tipo función.

## Macros Tipo Objeto (Constantes Simbólicas)

Estas son las macros más simples. Se usan para definir constantes simbólicas, asociando un nombre a un valor literal.

**Sintaxis:**
`#define NOMBRE_DE_LA_MACRO texto_de_reemplazo`

**Ejemplo:**

```c
#define PI 3.14159
#define MENSAJE_BIENVENIDA "Hola, bienvenido al programa."
#define MAX_USUARIOS 100

double circunferencia = 2 * PI * radio;
printf("%s\n", MENSAJE_BIENVENIDA);
int usuarios[MAX_USUARIOS];
```

**Ventajas sobre `const`:**

- Pueden ser usadas en contextos donde las variables `const` no pueden, como en la definición del tamaño de un arreglo estático en versiones antiguas de C.
- Pueden ser verificadas con `#ifdef` o `#if defined()`.

**Desventajas:**

- No tienen información de tipo. `PI` es solo el texto `3.14159`, no un `double`.
- No respetan el alcance (scope); una vez definidas, existen hasta el final del archivo (o hasta un `#undef`).

## Macros Tipo Función

Estas macros aceptan argumentos, lo que las hace parecer funciones, pero su mecanismo es completamente diferente.

**Sintaxis:**
`#define NOMBRE_MACRO(arg1, arg2, ...) cuerpo_de_la_macro`

**Ejemplo:**

```c
#define CUADRADO(x) ((x) * (x))
#define MAX(a, b) ((a) > (b) ? (a) : (b))

int resultado = CUADRADO(5); // Se expande a: int resultado = ((5) * (5));
int mayor = MAX(x + 1, y); // Se expande a: int mayor = ((x + 1) > (y) ? (x + 1) : (y));
```

### ¡Peligro! Los Errores Comunes de las Macros

La sustitución de texto literal es la fuente de muchos errores sutiles si no se toman precauciones.

**1. Problemas de Precedencia de Operadores:**

```c
#define CUADRADO_MALO(x) x * x
int res = CUADRADO_MALO(3 + 2); // Se expande a: 3 + 2 * 3 + 2 = 3 + 6 + 2 = 11 (¡Incorrecto!)
```

**Solución:** Siempre encierra cada argumento y toda la expresión de la macro entre paréntesis.

```c
#define CUADRADO_BUENO(x) ((x) * (x))
int res = CUADRADO_BUENO(3 + 2); // Se expande a: ((3 + 2) * (3 + 2)) = 5 * 5 = 25 (¡Correcto!)
```

**2. Efectos Secundarios por Doble Evaluación:**

```c
#define MAX(a, b) ((a) > (b) ? (a) : (b))
int x = 5, y = 10;
int z = MAX(x++, y++); // ¡CUIDADO!
```

La expansión es: `int z = ((x++) > (y++) ? (x++) : (y++));`

- Se compara `5 > 10` (falso). `x` se convierte en `6`, `y` en `11`.
- Se evalúa la parte falsa, `y++`. `z` toma el valor `11` y `y` se convierte en `12`.
- Resultado final: `z` es `11`, `x` es `6`, `y` es `12`. El comportamiento es inesperado porque `y++` se evaluó dos veces.

**Regla de Oro:** **Nunca uses argumentos con efectos secundarios (como `++`, `--` o llamadas a funciones) en una macro.**

## Comparación: Macros vs. Funciones

| Característica         | Macros Tipo Función                                                                                                                            | Funciones Reales                                                     |
| :--------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------- |
| **Mecanismo**          | Sustitución de texto por el preprocesador.                                                                                                     | Llamada a una subrutina en tiempo de ejecución.                      |
| **Sobrecarga de Tipo** | No hay tipos. El código se genera en el lugar de la llamada.                                                                                   | Requiere comprobación de tipos estricta.                             |
| **Rendimiento**        | Generalmente más rápidas para operaciones muy simples, ya que evitan la sobrecarga de una llamada a función (apilar argumentos, saltar, etc.). | Tienen una pequeña sobrecarga por la llamada.                        |
| **Tamaño del Código**  | Pueden aumentar el tamaño del ejecutable si la macro es grande y se usa muchas veces (el código se duplica).                                   | El código de la función existe una sola vez en el ejecutable.        |
| **Depuración**         | Difícil. El depurador ve el código expandido, no la macro. No se puede poner un breakpoint en una macro.                                       | Fácil. Se puede entrar en una función y depurarla paso a paso.       |
| **Seguridad**          | Propensas a errores de precedencia y efectos secundarios.                                                                                      | Seguras. Los argumentos se evalúan una sola vez antes de la llamada. |

**¿Cuándo usar macros?**
En C moderno, el uso de macros tipo función se desaconseja en favor de las **funciones `inline`**, que ofrecen los beneficios de rendimiento de una macro (sugiriendo al compilador que inserte el código en el lugar de la llamada) con la seguridad de tipos y la semántica de una función real.

Las macros siguen siendo útiles para:

- Definir constantes simbólicas.
- Compilación condicional.
- Tareas muy específicas de manipulación de texto en el código.

## La Directiva `#undef`

Puedes "des-definir" una macro para limitar su alcance.

```c
#define MI_MACRO 10
// ... código donde MI_MACRO es 10 ...
#undef MI_MACRO
// ... aquí MI_MACRO ya no está definida ...
```

## Resumen

- Las macros son una potente herramienta de sustitución de texto.
- Son excelentes para constantes simbólicas, pero peligrosas para operaciones tipo función si no se manejan con extremo cuidado.
- **Siempre** usa paréntesis en las macros tipo función.
- **Nunca** uses argumentos con efectos secundarios.
- En C moderno, prefiere funciones `inline` a macros tipo función siempre que sea posible.

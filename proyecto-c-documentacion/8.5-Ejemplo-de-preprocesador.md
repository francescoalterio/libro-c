# 8.5. Ejemplo Integrador del Preprocesador

Para consolidar los conceptos de las directivas del preprocesador, vamos a crear un pequeño proyecto que utiliza `#include`, `#define` y compilación condicional de manera conjunta.

El objetivo es crear un programa de registro de eventos (logging) simple. Tendremos un archivo de cabecera que define las macros de logging y un archivo principal que las utiliza. El nivel de logging (cuánta información se muestra) se controlará mediante macros.

## Estructura del Proyecto

```
proyecto/
├── logger.h      // Nuestro archivo de cabecera con las macros de logging
└── main.c        // El programa principal que usa el logger
```

### `logger.h`: El Cabecera del Logger

Este archivo contendrá toda la lógica del preprocesador. Usará guardas de inclusión y definirá macros de logging que solo se activarán si se definen ciertos niveles.

```c
// logger.h

#ifndef LOGGER_H_
#define LOGGER_H_

#include <stdio.h> // Necesario para printf

// --- NIVELES DE LOGGING ---
// El usuario de este cabecera puede definir LOG_LEVEL antes de incluirlo.
// Si no se define, por defecto será 1.
#ifndef LOG_LEVEL
#define LOG_LEVEL 1
#endif

// --- MACROS DE LOGGING ---

// LOG_ERROR: Siempre se muestra (nivel >= 0)
#define LOG_ERROR(mensaje, ...) printf("[ERROR] " mensaje "\n", ##__VA_ARGS__)

// LOG_INFO: Se muestra si LOG_LEVEL es 1 o superior
#if LOG_LEVEL >= 1
#define LOG_INFO(mensaje, ...) printf("[INFO] " mensaje "\n", ##__VA_ARGS__)
#else
#define LOG_INFO(mensaje, ...) // Se expande a nada
#endif

// LOG_DEBUG: Se muestra solo si LOG_LEVEL es 2 o superior
#if LOG_LEVEL >= 2
#define LOG_DEBUG(mensaje, ...) printf("[DEBUG] (%s:%d) " mensaje "\n", __FILE__, __LINE__, ##__VA_ARGS__)
#else
#define LOG_DEBUG(mensaje, ...) // Se expande a nada
#endif

#endif // LOGGER_H_
```

**Análisis de `logger.h`:**

- **Guardas de Inclusión**: `ifndef/define/endif LOGGER_H_` para evitar la inclusión múltiple.
- **Configuración por Defecto**: Si el usuario no define `LOG_LEVEL`, se establece en `1` por defecto. Esto hace que el logger sea fácil de usar.
- **Macros Variádicas**: Las macros usan `...` y `##__VA_ARGS__` para aceptar un número variable de argumentos, al igual que `printf`. `##` se asegura de que la coma se elimine si no hay argumentos extra.
- **Compilación Condicional**:
  - `LOG_ERROR` siempre está activa.
  - `LOG_INFO` se compila a un `printf` solo si `LOG_LEVEL` es `1` o `2`. Si no, se compila a una línea vacía, sin coste en tiempo de ejecución.
  - `LOG_DEBUG` solo se activa en el nivel más alto (`2`).
- **Macros Predefinidas**: `LOG_DEBUG` utiliza `__FILE__` y `__LINE__`, que son macros especiales que el preprocesador reemplaza por el nombre del archivo y el número de línea actual, respectivamente. ¡Muy útil para depurar!

### `main.c`: Uso del Logger

Este archivo incluye `logger.h` y utiliza las macros. Podemos cambiar el comportamiento del programa simplemente cambiando la definición de `LOG_LEVEL`.

```c
// main.c

// Define el nivel de logging ANTES de incluir el cabecera.
// Prueba a cambiar este valor a 0, 1 o 2.
#define LOG_LEVEL 2

#include "logger.h"

void operacion_critica() {
    LOG_DEBUG("Iniciando operación crítica con %d reintentos.", 3);
    // ... lógica de la función ...
    LOG_INFO("La operación ha finalizado.");
}

int main() {
    LOG_INFO("El programa ha comenzado.");

    int exito = 0; // Supongamos que algo falla
    if (!exito) {
        LOG_ERROR("¡Ha ocurrido un fallo! Código de error: %d.", 123);
    }

    operacion_critica();

    LOG_INFO("El programa va a terminar.");

    return 0;
}
```

### Cómo Funciona la Compilación

1.  **Si `LOG_LEVEL` es `2` (Máximo detalle):**

    - `LOG_ERROR`, `LOG_INFO` y `LOG_DEBUG` se expanden a llamadas a `printf`.
    - **Salida:**
      ```
      [INFO] El programa ha comenzado.
      [ERROR] ¡Ha ocurrido un fallo! Código de error: 123.
      [DEBUG] (main.c:14) Iniciando operación crítica con 3 reintentos.
      [INFO] La operación ha finalizado.
      [INFO] El programa va a terminar.
      ```

2.  **Si `LOG_LEVEL` es `1` (Por defecto):**

    - `LOG_DEBUG` se expande a nada. El compilador ni siquiera verá la llamada a `printf` de depuración.
    - **Salida:**
      ```
      [INFO] El programa ha comenzado.
      [ERROR] ¡Ha ocurrido un fallo! Código de error: 123.
      [INFO] La operación ha finalizado.
      [INFO] El programa va a terminar.
      ```

3.  **Si `LOG_LEVEL` es `0` (Solo errores):**
    - `LOG_INFO` y `LOG_DEBUG` se expanden a nada.
    - **Salida:**
      ```
      [ERROR] ¡Ha ocurrido un fallo! Código de error: 123.
      ```

## Conclusión del Ejemplo

Este ejemplo demuestra cómo las directivas del preprocesador trabajan juntas para crear un sistema flexible y eficiente.

- `#include` modulariza el código (separa el logger del programa principal).
- `#define` crea una "API" de logging fácil de usar (`LOG_INFO`, etc.).
- La compilación condicional (`#if`, `#ifndef`) permite crear diferentes "versiones" del código (con más o menos detalle de logging) sin cambiar la lógica principal y sin ningún coste de rendimiento en las versiones de producción, ya que las llamadas a `printf` innecesarias se eliminan por completo antes de la compilación.
